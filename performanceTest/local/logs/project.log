2022-04-25 17:55:23-log: [Package] menu@1.0.0 enable
2022-04-25 17:55:23-log: [Package] profile@1.0.0 enable
2022-04-25 17:55:23-log: [Package] project@1.0.1 enable
2022-04-25 17:55:23-log: [Package] messages@1.0.0 enable
2022-04-25 17:55:23-log: [Package] program@1.0.0 enable
2022-04-25 17:55:23-log: [Package] device@1.0.1 enable
2022-04-25 17:55:23-log: [Package] ui-kit@1.0.1 enable
2022-04-25 17:55:23-log: [Package] tester@1.0.0 enable
2022-04-25 17:55:23-log: [Package] preferences@1.0.0 enable
2022-04-25 17:55:24-log: Setup mods mgr.: 209.613ms
2022-04-25 17:55:24-log: Profile changed: engine (modules.includeModules: 2d,3d,audio,base,dragon-bones,gfx-webgl,gfx-webgl2,intersection-2d,marionette,particle,particle-2d,physics-2d-box2d,physics-ammo,primitive,profiler,spine,terrain,tiled-map,tween,ui,video,webview)
2022-04-25 17:55:24-log: [Package] engine@1.0.5 enable
2022-04-25 17:55:25-log: [Package] programming@1.0.0 enable
2022-04-25 17:55:25-log: [Package] engine-extends@1.0.0 enable
2022-04-25 17:55:25-log: [Package] asset-db@1.0.0 enable
2022-04-25 17:55:25-log: [Package] console@1.0.0 enable
2022-04-25 17:55:26-log: [Package] scene@1.0.0 enable
2022-04-25 17:55:26-log: [Package] server@1.0.0 enable
2022-04-25 17:55:26-log: [Package] utils@1.0.0 enable
2022-04-25 17:55:26-log: [Package] assets@1.0.0 enable
2022-04-25 17:55:26-log: [Package] inspector@1.0.0 enable
2022-04-25 17:55:26-log: [Package] hierarchy@1.0.0 enable
2022-04-25 17:55:27-log: [Package] preview@1.0.1 enable
2022-04-25 17:55:27-log: [Package] animator@1.0.0 enable
2022-04-25 17:55:27-log: [Package] builder@1.3.1 enable
2022-04-25 17:55:27-log: [Package] node-library@1.0.0 enable
2022-04-25 17:55:28-log: [Package] shortcuts@1.0.1 enable
2022-04-25 17:55:28-log: [Package] package-asset@1.0.0 enable
2022-04-25 17:55:28-log: [Package] reference-image@1.0.0 enable
2022-04-25 17:55:28-log: [Package] animation-graph@1.0.0 enable
2022-04-25 17:55:28-log: [Package] channel-upload-tools@1.0.0 enable
2022-04-25 17:55:28-log: [Package] runtime-dev-tools@1.0.0 enable
2022-04-25 17:55:28-log: [Package] lightmap@1.0.4 enable
2022-04-25 17:55:28-log: [Package] alipay-mini-game@1.0.0 enable
2022-04-25 17:55:28-log: [Package] android@1.0.0 enable
2022-04-25 17:55:28-log: [Package] baidu-mini-game@1.0.0 enable
2022-04-25 17:55:28-log: [Package] bytedance-mini-game@1.0.1 enable
2022-04-25 17:55:28-log: [Package] huawei-agc@1.0.0 enable
2022-04-25 17:55:28-log: [Package] ios@1.0.0 enable
2022-04-25 17:55:28-log: [Package] ios-app-clip@1.0.0 enable
2022-04-25 17:55:28-log: [Package] mac@1.0.0 enable
2022-04-25 17:55:28-log: [Package] native@1.0.0 enable
2022-04-25 17:55:28-log: [Package] ohos@1.0.0 enable
2022-04-25 17:55:28-log: [Package] web-desktop@1.0.0 enable
2022-04-25 17:55:28-log: [Package] web-mobile@1.0.0 enable
2022-04-25 17:55:28-log: [Package] wechatgame@1.0.1 enable
2022-04-25 17:55:28-log: [Package] windows@1.0.0 enable
2022-04-25 17:55:28-log: [Package] xiaomi-quick-game@1.0.0 enable
2022-04-25 17:55:28-log: [Package] cocos-play@1.0.0 enable
2022-04-25 17:55:28-log: [Package] huawei-quick-game@1.0.0 enable
2022-04-25 17:55:28-log: [Package] link-sure@1.0.0 enable
2022-04-25 17:55:28-log: [Package] oppo-mini-game@1.0.0 enable
2022-04-25 17:55:28-log: [Package] qtt@1.0.0 enable
2022-04-25 17:55:28-log: [Package] vivo-mini-game@1.0.0 enable
2022-04-25 17:55:28-log: [Package] cocos-service@3.0.2 enable
2022-04-25 17:55:28-log: [Package] importer@1.0.0 enable
2022-04-25 17:55:29-log: [Package] extension@3.0.15 enable
2022-04-25 17:55:29-log: [Im-plugin] Check im-plugin version.
2022-04-25 17:55:29-log: [Package] im-plugin@3.0.8 enable
2022-04-25 17:55:29-log: [Im-plugin] No online info of im-plugin.
2022-04-25 17:55:36-warn: [Asset DB] 材质 [face_eyeball] 的 [Transparent color] 属性不允许是贴图。 [{asset(3e4bec32-3bc0-4cb4-b5d2-8a380402eea1)}]
2022-04-25 17:55:42-warn: Browserslist: caniuse-lite is outdated. Please run:
npx browserslist@latest --update-db

Why you should do it regularly:
https://github.com/browserslist/browserslist#browsers-data-updating
2022-04-25 17:55:43-log: [Scene] Cocos Creator v3.4.2
2022-04-25 17:55:43-info: [Scene] Forward render pipeline initialized.
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:55:49-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:56:08-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:56:08-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:56:08-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-25 17:56:39-warn: [Scene] Node "cjie2" has no path "root/footsteps".
2022-04-26T14:33:48.581Z - log: [Package] menu@1.0.0 enable
2022-04-26T14:33:48.582Z - log: [Package] profile@1.0.0 enable
2022-04-26T14:33:48.588Z - log: [Package] project@1.0.2 enable
2022-04-26T14:33:48.592Z - log: [Package] messages@1.0.0 enable
2022-04-26T14:33:48.593Z - log: [Package] program@1.0.0 enable
2022-04-26T14:33:48.597Z - log: [Package] tester@1.0.0 enable
2022-04-26T14:33:48.600Z - log: [Package] preferences@1.0.0 enable
2022-04-26T14:33:49.006Z - log: Setup mods mgr.: 221.233ms
2022-04-26T14:33:49.010Z - verbose: [Engine] QuickCompile engine (374ms)
2022-04-26T14:33:49.012Z - log: [Package] engine@1.0.6 enable
2022-04-26T14:33:49.778Z - log: [Package] programming@1.0.0 enable
2022-04-26T14:33:50.029Z - log: [Package] device@1.0.1 enable
2022-04-26T14:33:50.053Z - log: [Package] ui-kit@1.0.1 enable
2022-04-26T14:33:50.076Z - log: [Package] engine-extends@1.0.0 enable
2022-04-26T14:33:50.125Z - log: [Package] asset-db@1.0.0 enable
2022-04-26T14:33:50.158Z - log: [Package] scene@1.0.0 enable
2022-04-26T14:33:50.279Z - log: [Package] server@1.0.0 enable
2022-04-26T14:33:50.306Z - log: [Package] utils@1.0.0 enable
2022-04-26T14:33:52.619Z - log: [Package] preview@1.0.1 enable
2022-04-26T14:33:52.650Z - log: [Package] animator@1.0.0 enable
2022-04-26T14:33:53.439Z - log: Profile changed: builder (log.level: 2)
2022-04-26T14:33:53.446Z - log: [Package] builder@1.3.2 enable
2022-04-26T14:33:53.476Z - log: [Package] shortcuts@1.0.1 enable
2022-04-26T14:33:53.504Z - log: [Package] animation-graph@1.0.0 enable
2022-04-26T14:33:53.527Z - log: [Package] runtime-dev-tools@1.0.0 enable
2022-04-26T14:33:53.548Z - log: [Package] channel-upload-tools@1.0.0 enable
2022-04-26T14:33:53.577Z - log: [Package] about@1.0.0 enable
2022-04-26T14:33:53.608Z - log: [Package] assets@1.0.0 enable
2022-04-26T14:33:53.637Z - log: [Package] console@1.0.0 enable
2022-04-26T14:33:53.759Z - log: [Package] extension@3.0.16 enable
2022-04-26T14:33:53.789Z - log: [Package] hierarchy@1.0.0 enable
2022-04-26T14:33:53.819Z - log: [Package] inspector@1.0.0 enable
2022-04-26T14:33:53.848Z - log: [Package] lightmap@1.0.4 enable
2022-04-26T14:33:53.858Z - verbose: [AssetDB] Require engine code (817ms)
2022-04-26T14:33:53.891Z - log: [Package] node-library@1.0.1 enable
2022-04-26T14:33:53.914Z - log: [Package] package-asset@1.0.0 enable
2022-04-26T14:33:53.943Z - log: [Package] process@1.0.0 enable
2022-04-26T14:33:53.977Z - log: [Package] reference-image@1.0.0 enable
2022-04-26T14:33:53.997Z - log: [Package] alipay-mini-game@1.0.0 enable
2022-04-26T14:33:54.020Z - log: [Package] android@1.0.0 enable
2022-04-26T14:33:54.043Z - log: [Package] baidu-mini-game@1.0.0 enable
2022-04-26T14:33:54.064Z - log: [Package] bytedance-mini-game@1.0.1 enable
2022-04-26T14:33:54.085Z - log: [Package] cocos-play@1.0.0 enable
2022-04-26T14:33:54.109Z - log: [Package] huawei-agc@1.0.0 enable
2022-04-26T14:33:54.131Z - log: [Package] huawei-quick-game@1.0.0 enable
2022-04-26T14:33:54.155Z - log: [Package] ios@1.0.0 enable
2022-04-26T14:33:54.178Z - log: [Package] ios-app-clip@1.0.0 enable
2022-04-26T14:33:54.199Z - log: [Package] link-sure@1.0.0 enable
2022-04-26T14:33:54.222Z - log: [Package] linux@1.0.0 enable
2022-04-26T14:33:54.245Z - log: [Package] mac@1.0.0 enable
2022-04-26T14:33:54.318Z - log: [Package] native@1.0.0 enable
2022-04-26T14:33:54.341Z - log: [Package] ohos@1.0.0 enable
2022-04-26T14:33:54.364Z - log: [Package] open-harmonyos@1.0.0 enable
2022-04-26T14:33:54.386Z - log: [Package] oppo-mini-game@1.0.0 enable
2022-04-26T14:33:54.409Z - log: [Package] qtt@1.0.0 enable
2022-04-26T14:33:54.433Z - log: [Package] vivo-mini-game@1.0.0 enable
2022-04-26T14:33:54.466Z - log: [Package] web-desktop@1.0.0 enable
2022-04-26T14:33:54.499Z - log: [Package] web-mobile@1.0.0 enable
2022-04-26T14:33:54.531Z - log: [Package] wechatgame@1.0.1 enable
2022-04-26T14:33:54.554Z - log: [Package] windows@1.0.0 enable
2022-04-26T14:33:54.576Z - log: [Package] xiaomi-quick-game@1.0.0 enable
2022-04-26T14:33:54.753Z - log: [Package] cocos-service@3.0.3 enable
2022-04-26T14:33:54.784Z - log: [Package] importer@1.0.0 enable
2022-04-26T14:33:54.967Z - log: [Im-plugin] Check im-plugin version.
2022-04-26T14:33:54.978Z - log: [Package] im-plugin@3.0.8 enable
2022-04-26T14:33:55.466Z - log: [Im-plugin] No online info of im-plugin.
2022-04-26T14:33:59.204Z - error: [Asset DB] ../test/builtin-standard-anisotropy-001.effect - standard-fs: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:929: '[' : syntax error
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define CC_USE_FOG 0
24 #define CC_USE_ACCURATE_FOG 1
25 #define USE_VERTEX_COLOR 1
26 #define HAS_SECOND_UV 1
27 #define CC_FORWARD_ADD 1
28 #define USE_NORMAL_MAP 1
29 #define SAMPLE_FROM_RT 1
30 #define CC_USE_IBL 0
31 #define CC_USE_DIFFUSEMAP 0
32 #define USE_REFLECTION_DENOISE 1
33 #define CC_USE_HDR 1
34 #define USE_ALBEDO_MAP 1
35 #define USE_PBR_MAP 1
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define USE_OCCLUSION_MAP 1
38 #define USE_EMISSIVE_MAP 1
39 #define USE_ALPHA_TEST 1
40 #define USE_ANISOTROPY 1
41 #define CC_PIPELINE_TYPE 0
42 #define CC_FORCE_FORWARD_SHADING 1
43 
44 #ifdef GL_EXT_draw_buffers
45 #extension GL_EXT_draw_buffers: enable
46 #endif
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp mat4 cc_matView;
58   uniform highp vec4 cc_cameraPos;
59   uniform mediump vec4 cc_mainLitDir;
60   uniform mediump vec4 cc_mainLitColor;
61   uniform mediump vec4 cc_ambientSky;
62   uniform mediump vec4 cc_ambientGround;
63   uniform mediump vec4 cc_fogColor;
64   uniform mediump vec4 cc_fogBase;
65   uniform mediump vec4 cc_fogAdd;
66   uniform mediump vec4 cc_nearFar;
67   uniform mediump vec4 cc_viewPort;
68 
69 
70 
71      uniform vec4 albedo;
72      uniform vec4 albedoScaleAndCutoff;
73      uniform vec4 pbrParams;
74      uniform vec4 miscParams;
75      uniform vec4 emissive;
76      uniform vec4 emissiveScaleParam;
77      uniform vec4 anisoTile;
78      uniform vec4 hairBaseColor;
79      uniform vec4 hairSpecColor01;
80      uniform vec4 hairSpecColor02;
81      uniform vec2 anisoJitter;
82      uniform float anisoAOStrength;
83      uniform float hairSpecMOffset;
84      uniform float hairSpecAOffset;
85      uniform float hairSpecMAmt;
86      uniform float hairSpecAAmt;
87      uniform float hairSpecIntensity;
88 
89 float LinearFog(vec4 pos) {
90   vec4 wPos = pos;
91   float cam_dis = distance(cc_cameraPos, wPos);
92   float fogStart = cc_fogBase.x;
93   float fogEnd = cc_fogBase.y;
94   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);
95 }
96 
97 float ExpFog(vec4 pos) {
98   vec4 wPos = pos;
99   float fogAtten = cc_fogAdd.z;
100   float fogStart = cc_fogBase.x;
101   float fogDensity = cc_fogBase.z;
102   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
103   float f = exp(-cam_dis * fogDensity);
104   return f;
105 }
106 
107 float ExpSquaredFog(vec4 pos) {
108   vec4 wPos = pos;
109   float fogAtten = cc_fogAdd.z;
110   float fogStart = cc_fogBase.x;
111   float fogDensity = cc_fogBase.z;
112   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
113   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);
114   return f;
115 }
116 
117 float LayeredFog(vec4 pos) {
118   vec4 wPos = pos;
119   float fogAtten = cc_fogAdd.z;
120   float _FogTop = cc_fogAdd.x;
121   float _FogRange = cc_fogAdd.y;
122   vec3 camWorldProj = cc_cameraPos.xyz;
123   camWorldProj.y = 0.;
124   vec3 worldPosProj = wPos.xyz;
125   worldPosProj.y = 0.;
126   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;
127   float fDeltaY, fDensityIntegral;
128   if (cc_cameraPos.y > _FogTop) {
129     if (wPos.y < _FogTop) {
130       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;
131       fDensityIntegral = fDeltaY * fDeltaY * 0.5;
132     } else {
133       fDeltaY = 0.;
134       fDensityIntegral = 0.;
135     }
136   } else {
137     if (wPos.y < _FogTop) {
138       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;
139       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;
140       fDeltaY = abs(fDeltaA - fDeltaB);
141       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));
142     } else {
143       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;
144       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);
145     }
146   }
147   float fDensity;
148   if (fDeltaY != 0.) {
149     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;
150   } else {
151     fDensity = 0.;
152   }
153   float f = exp(-fDensity);
154   return f;
155 }
156 
157 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)
158 {
159   #if CC_USE_FOG == 0
160 	factor = LinearFog(pos);
161   #elif CC_USE_FOG == 1
162     factor = ExpFog(pos);
163   #elif CC_USE_FOG == 2
164     factor = ExpSquaredFog(pos);
165   #elif CC_USE_FOG == 3
166     factor = LayeredFog(pos);
167   #else
168     factor = 1.0;
169   #endif
170 }
171 
172 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {
173   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);
174 }
175 
176 
177 #if !CC_USE_ACCURATE_FOG
178 varying float v_fog_factor;
179 #endif
180 
181 void CC_APPLY_FOG(inout vec4 color) {
182 #if !CC_USE_ACCURATE_FOG
183     CC_APPLY_FOG_BASE(color, v_fog_factor);
184 #endif
185 }
186 
187 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {
188 #if CC_USE_ACCURATE_FOG
189     float factor;
190     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);
191 #else
192     float factor = v_fog_factor;
193 #endif
194     CC_APPLY_FOG_BASE(color, factor);
195 }
196 
197 vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
198   
199     #ifdef GL_EXT_shader_texture_lod
200       return texture2DLodEXT(tex, coord, lod);
201     #else
202       return texture2D(tex, coord, lod);
203     #endif
204   
205 }
206 
207 vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
208   
209     #ifdef GL_EXT_shader_texture_lod
210       return textureCubeLodEXT(tex, coord, lod);
211     #else
212       return textureCube(tex, coord, lod);
213     #endif
214   
215 }
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 #define QUATER_PI         0.78539816340
228 #define HALF_PI           1.57079632679
229 #define PI                3.14159265359
230 #define PI2               6.28318530718
231 #define PI4               12.5663706144
232      
233 #define INV_QUATER_PI     1.27323954474
234 #define INV_HALF_PI       0.63661977237
235 #define INV_PI            0.31830988618
236 #define INV_PI2           0.15915494309
237 #define INV_PI4           0.07957747155
238      
239 #define EPSILON           1e-6
240 #define EPSILON_LOWP      1e-4
241 #define LOG2              1.442695
242 #define EXP_VALUE         2.71828183f
243 #define FP_MAX            65504.0
244 #define FP_SCALE          0.0009765625
245 #define FP_SCALE_INV      1024.0
246 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
247 
248 
249 
250 
251 
252 
253 
254 vec3 SRGBToLinear (vec3 gamma) {
255   return gamma * gamma;
256 }
257 uniform highp mat4 cc_matLightView;
258   uniform highp vec4 cc_shadowInvProjDepthInfo;
259   uniform highp vec4 cc_shadowProjDepthInfo;
260   uniform highp vec4 cc_shadowProjInfo;
261   uniform mediump vec4 cc_shadowNFLSInfo;
262   uniform mediump vec4 cc_shadowWHPBInfo;
263   uniform mediump vec4 cc_shadowLPNNInfo;
264 
265 
266 
267 
268 
269 
270 
271 
272 highp float unpackHighpData (float mainPart, float modPart) {
273   highp float data = mainPart;
274   return data + modPart;
275 }
276 
277 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
278   highp float data = mainPart * modValue;
279   return data + modPart * modValue;
280 }
281 
282 
283 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
284   highp vec2 data = mainPart;
285   return data + modPart;
286 }
287 
288 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
289   highp vec2 data = mainPart * modValue;
290   return data + modPart * modValue;
291 }
292 
293 
294 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
295   highp vec3 data = mainPart;
296   return data + modPart;
297 }
298 
299 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
300   highp vec3 data = mainPart * modValue;
301   return data + modPart * modValue;
302 }
303 
304 
305 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
306   highp vec4 data = mainPart;
307   return data + modPart;
308 }
309 
310 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
311   highp vec4 data = mainPart * modValue;
312   return data + modPart * modValue;
313 }
314 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {
315   float dist = length(viewPos);
316   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);
317 }
318 
319 float CCGetLinearDepth(vec3 worldPos) {
320   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);
321   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);
322 }
323 
324 
325 
326 #if CC_RECEIVE_SHADOW
327   uniform highp sampler2D cc_shadowMap;
328   uniform highp sampler2D cc_spotLightingMap;
329 
330   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
331   {
332     vec4 newShadowPos = shadowPos;
333     if(normalBias > EPSILON_LOWP)
334     {
335       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
336       if(viewNormal.z < 0.1)
337         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
338     }
339     return newShadowPos;
340   }
341   
342   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)
343   {
344     vec3 viewSpacePos;
345     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;
346     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;
347     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;
348     vec4 clipSpacePos;
349     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;
350     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);
351     if (cc_shadowNFLSInfo.z > EPSILON) {
352       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);
353       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;
354     }
355 
356     return clipSpacePos;
357   }
358 
359   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
360   {
361     float coeffA = cc_shadowProjDepthInfo.x;
362     float coeffB = cc_shadowProjDepthInfo.y;
363     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
364     viewSpacePos_z += viewspaceDepthBias;
365     vec4 result = shadowPos;
366     result.z = viewSpacePos_z * coeffA + coeffB;
367     return result;
368   }
369   
370   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
371     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
372     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
373     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
374         clipPos.y < 0.0 || clipPos.y > 1.0 ||
375         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
376     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
377 
378     float shadow = 0.0;
379     float closestDepth = 0.0;
380     if (cc_shadowLPNNInfo.y > EPSILON) {
381       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
382     } else {
383       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
384     }
385     shadow = step(clipPos.z, closestDepth);
386 
387     return shadow;
388   }
389 
390   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
391     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
392     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
393     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
394         clipPos.y < 0.0 || clipPos.y > 1.0 ||
395         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
396     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
397 
398     float offsetDepth = clipPos.z;
399     vec2 mapSize = cc_shadowWHPBInfo.xy;
400     vec2 oneTap = 1.0 / mapSize;
401     vec2 clipPos_offset = clipPos.xy + oneTap;
402 
403     float block0, block1, block2, block3;
404     if (cc_shadowLPNNInfo.y > EPSILON) {
405       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
406       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
407       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
408       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
409     } else {
410       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
411       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
412       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
413       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
414     }
415 
416     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
417     float resultX = mix(block0, block1, coefX);
418     float resultY = mix(block2, block3, coefX);
419     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
420 
421     return mix(resultX, resultY, coefY);
422   }
423 
424   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
425     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
426     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
427     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
428         clipPos.y < 0.0 || clipPos.y > 1.0 ||
429         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
430     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
431 
432     float offsetDepth = clipPos.z;
433     vec2 mapSize = cc_shadowWHPBInfo.xy;
434     vec2 oneTap = 1.0 / mapSize;
435     float clipPos_offset_L = clipPos.x - oneTap.x;
436     float clipPos_offset_R = clipPos.x + oneTap.x;
437     float clipPos_offset_U = clipPos.y - oneTap.y;
438     float clipPos_offset_D = clipPos.y + oneTap.y;
439 
440     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
441     if (cc_shadowLPNNInfo.y > EPSILON) {
442       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
443       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
444       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
445       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
446       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
447       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
448       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
449       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
450       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
451     } else {
452       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
453       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
454       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
455       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
456       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
457       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
458       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
459       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
460       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
461     }
462 
463     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
464     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
465 
466     float shadow = 0.0;
467     float resultX = mix(block0, block1, coefX);
468     float resultY = mix(block3, block4, coefX);
469     shadow += mix(resultX , resultY, coefY);
470 
471     resultX = mix(block1, block2, coefX);
472     resultY = mix(block4, block5, coefX);
473     shadow += mix(resultX , resultY, coefY);
474 
475     resultX = mix(block3, block4, coefX);
476     resultY = mix(block6, block7, coefX);
477     shadow += mix(resultX, resultY, coefY);
478 
479     resultX = mix(block4, block5, coefX);
480     resultY = mix(block7, block8, coefX);
481     shadow += mix(resultX, resultY, coefY);
482 
483     return shadow * 0.25;
484   }
485 
486   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {
487     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
488     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
489     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
490         clipPos.y < 0.0 || clipPos.y > 1.0 ||
491         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
492     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
493 
494     float shadow = 0.0;
495     float closestDepth = 0.0;
496     float depth = clipPos.z;
497 
498     if (cc_shadowLPNNInfo.y > EPSILON) {
499       closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
500     } else {
501       closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;
502     }
503     shadow = step(depth, closestDepth);
504 
505     return shadow;
506   }
507 
508   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {
509     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
510     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
511     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
512         clipPos.y < 0.0 || clipPos.y > 1.0 ||
513         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
514     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
515 
516     float depth = 0.0;
517     if (cc_shadowNFLSInfo.z > EPSILON) {
518       depth = CCGetLinearDepth(worldPos);
519     } else {
520       depth = clipPos.z;
521     }
522 
523     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;
524     vec2 clipPos_offset = clipPos.xy + oneTap;
525 
526     float block0, block1, block2, block3;
527     if (cc_shadowLPNNInfo.y > EPSILON) {
528       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
529       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
530       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
531       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
532     } else {
533       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
534       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);
535       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);
536       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
537     }
538 
539     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;
540     float resultX = mix(block0, block1, coefX);
541     float resultY = mix(block2, block3, coefX);
542     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;
543 
544     return mix(resultX, resultY, coefY);
545   }
546 
547   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {
548     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
549     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
550     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
551         clipPos.y < 0.0 || clipPos.y > 1.0 ||
552         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
553     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
554 
555     float depth = 0.0;
556     if (cc_shadowNFLSInfo.z > EPSILON) {
557       depth = CCGetLinearDepth(worldPos);
558     } else {
559       depth = clipPos.z;
560     }
561 
562     vec2 mapSize = cc_shadowWHPBInfo.xy;
563     vec2 oneTap = 1.0 / mapSize;
564     float clipPos_offset_L = clipPos.x - oneTap.x;
565     float clipPos_offset_R = clipPos.x + oneTap.x;
566     float clipPos_offset_U = clipPos.y - oneTap.y;
567     float clipPos_offset_D = clipPos.y + oneTap.y;
568 
569     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
570     if (cc_shadowLPNNInfo.y > EPSILON) {
571       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
572       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
573       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
574       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
575       block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
576       block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
577       block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
578       block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
579       block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
580     } else {
581       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
582       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);
583       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
584       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);
585       block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
586       block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);
587       block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
588       block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);
589       block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
590     }
591 
592     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
593     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
594 
595     float shadow = 0.0;
596     float resultX = mix(block0, block1, coefX);
597     float resultY = mix(block3, block4, coefX);
598     shadow += mix(resultX , resultY, coefY);
599 
600     resultX = mix(block1, block2, coefX);
601     resultY = mix(block4, block5, coefX);
602     shadow += mix(resultX , resultY, coefY);
603 
604     resultX = mix(block3, block4, coefX);
605     resultY = mix(block6, block7, coefX);
606     shadow += mix(resultX, resultY, coefY);
607 
608     resultX = mix(block4, block5, coefX);
609     resultY = mix(block7, block8, coefX);
610     shadow += mix(resultX, resultY, coefY);
611 
612     return shadow * 0.25;
613   }
614 
615 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
616 {
617   float pcf = cc_shadowWHPBInfo.z;
618   if (pcf > 1.9) { 
619     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);
620   }else if (pcf > 0.9) { 
621     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);
622   }else { 
623     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x); 
624   }
625 }
626 
627 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
628 {
629   float realtimeShadow = 1.0;
630   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
631   
632   float pcf = cc_shadowWHPBInfo.z;
633   if (pcf > 1.9) { 
634     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
635   }else if (pcf > 0.9) {
636     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
637   }else { 
638     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
639   }
640   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
641 }
642 #endif
643 
644 
645 
646 #if CC_USE_IBL
647   uniform samplerCube cc_environment;
648   
649 
650   
651   
652   vec3 unpackRGBE (vec4 rgbe) {
653     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
654   }
655   
656 
657   #if CC_USE_DIFFUSEMAP
658     uniform samplerCube cc_diffuseMap;
659   #endif
660 #endif
661 
662 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
663   vec3 NxH = cross(N, H);
664   float OneMinusNoHSqr = dot(NxH, NxH);
665   float a = roughness * roughness;
666   float n = NoH * a;
667   float p = a / (OneMinusNoHSqr + n * n);
668   return p * p;
669 }
670 
671 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
672   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
673 }
674 
675 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
676   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
677   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
678   vec4 r = roughness * c0 + c1;
679   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
680   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
681   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
682   return specular * AB.x + AB.y;
683 }
684 
685 #if USE_REFLECTION_DENOISE
686   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
687     #if CC_USE_IBL
688     	float mip = roughness * mipCount;
689     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
690     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
691 
692     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
693      	vec4 filtered = textureCube(cc_environment, R);
694 
695       #if CC_USE_IBL == 2
696       	biased.rgb = unpackRGBE(biased);
697       	filtered.rgb = unpackRGBE(filtered);
698       #else
699       	biased.rgb = SRGBToLinear(biased.rgb);
700       	filtered.rgb = SRGBToLinear(filtered.rgb);
701       #endif
702       	
703       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
704     #else
705       return vec3(0.0, 0.0, 0.0);
706     #endif
707   }
708 #endif
709 
710 
711 struct StandardSurface {
712   vec4 albedo;
713   
714   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
715   vec3 position, position_fract_part;
716   #else
717   vec3 position;
718   #endif
719   vec3 normal;
720   vec3 emissive;
721   vec3 lightmap;
722   float lightmap_test;
723   float roughness;
724   float metallic;
725   float occlusion;
726   float specularIntensity;
727 
728   #if CC_RECEIVE_SHADOW
729     vec2 shadowBias;
730   #endif
731 };
732 
733 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
734   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
735  
736   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
737 
738   vec3 position;
739   
740   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
741   position = unpackHighpData(s.position, s.position_fract_part);
742   #else
743   position = s.position;
744   #endif
745 
746   vec3 N = normalize(s.normal);
747   vec3 V = normalize(cc_cameraPos.xyz - position);
748 
749   float NV = max(abs(dot(N, V)), 0.0);
750   specular = BRDFApprox(specular, s.roughness, NV);
751 
752   vec3 L = normalize(-cc_mainLitDir.xyz);
753   vec3 H = normalize(L + V);
754   float NH = max(dot(N, H), 0.0);
755   float NL = max(dot(N, L), 0.0);
756   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
757   vec3 diffuseContrib = diffuse / PI;
758   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
759   vec3 dirlightContrib = (diffuseContrib + specularContrib);
760 
761   float shadow = 1.0;
762   #if CC_RECEIVE_SHADOW
763     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
764       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
765     }
766   #endif
767 
768   dirlightContrib *= shadow;
769   finalColor *= dirlightContrib;
770 
771   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
772     if (s.lightmap_test > EPSILON_LOWP) {
773       finalColor = diffuse * s.lightmap.rgb * shadow;
774     }
775   #endif
776 
777   float fAmb = 0.5 - N.y * 0.5;
778   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
779 
780 
781   #if CC_USE_IBL
782     #if CC_USE_DIFFUSEMAP
783       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
784       #if CC_USE_DIFFUSEMAP == 2
785         ambDiff = unpackRGBE(diffuseMap);
786       #else
787         ambDiff = SRGBToLinear(diffuseMap.rgb);
788       #endif
789     #endif
790 
791     vec3 R = normalize(reflect(-V, N));
792 
793     #if USE_REFLECTION_DENOISE
794       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
795     #else
796       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
797 
798       #if CC_USE_IBL == 2
799         vec3 env = unpackRGBE(envmap);
800       #else
801         vec3 env = SRGBToLinear(envmap.rgb);
802       #endif
803     #endif
804 
805     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
806   #endif
807 
808   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
809   
810 
811   finalColor += s.emissive;
812 
813   return vec4(finalColor, s.albedo.a);
814 }
815 
816 
817 
818 vec3 ACESToneMap (vec3 color) {
819   color = min(color, vec3(8.0));
820   const float A = 2.51;
821   const float B = 0.03;
822   const float C = 2.43;
823   const float D = 0.59;
824   const float E = 0.14;
825   return (color * (A * color + B)) / (color * (C * color + D) + E);
826 }
827 
828 
829 
830 vec4 CCFragOutput (vec4 color) {
831   #if CC_USE_HDR
832     color.rgb = ACESToneMap(color.rgb);
833   #endif
834   color.rgb = sqrt(color.rgb);
835   return color;
836 }
837 
838 
839 
840 
841 varying highp vec4 v_shadowPos;
842 
843 
844 
845 #if CC_RECEIVE_SHADOW
846 
847 
848 
849 #endif
850 
851 
852 
853 
854 #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
855   varying vec3 v_luv;
856   uniform sampler2D cc_lightingMap;
857   
858 #endif
859 
860 void alphaTestFunc(float alpha)
861 {
862   if (alpha < albedoScaleAndCutoff.w) discard;
863 }
864 
865 
866 varying vec3 v_position;
867 varying vec2 v_uv;
868 varying vec2 v_uv1;
869 varying vec3 v_normal;
870 varying vec3 v_tangent;
871 varying vec3 v_bitangent;
872 
873 varying vec4 worldViewDir;
874 varying vec4 worldHalfDir;
875 
876 #if USE_VERTEX_COLOR
877   varying vec4 v_color;
878 #endif
879 
880 #if USE_ALBEDO_MAP
881   uniform sampler2D albedoMap;
882   #endif
883 #if USE_NORMAL_MAP
884   uniform sampler2D normalMap;
885   #endif
886 #if USE_PBR_MAP
887   uniform sampler2D pbrMap;
888 #endif
889 #if USE_METALLIC_ROUGHNESS_MAP
890   uniform sampler2D metallicRoughnessMap;
891 #endif
892 #if USE_OCCLUSION_MAP
893   uniform sampler2D occlusionMap;
894 #endif
895 #if USE_EMISSIVE_MAP
896   uniform sampler2D emissiveMap;
897   #endif
898 
899 #define OCCLUSION_CHANNEL r
900 #define ROUGHNESS_CHANNEL g
901 #define METALLIC_CHANNEL  b
902 #define SPECULARINTENSITY_CHANNEL w
903 
904 
905 #if USE_ALPHA_TEST
906   #endif
907 
908 #if USE_ANISOTROPY
909   uniform sampler2D anisoRamp;
910 #endif
911 
912 float anisotropyIndex( float offset, float factor, float amt ) {
913   vec3 jitterN = v_bitangent + (v_normal * offset + factor);
914   float NHdot = dot(normalize(jitterN), normalize(worldHalfDir.xyz));
915   float sinNH = max(0.01, sqrt(1.0 - pow(NHdot, 2.0)));
916   float atten = smoothstep(-1.0, 0.0, NHdot);
917   return pow(sinNH, amt) * atten;
918 }
919 
920 void surf (out StandardSurface s) {
921   vec4 baseColor = albedo;
922 
923   #if USE_VERTEX_COLOR
924     baseColor.rgb *= SRGBToLinear(v_color.rgb);
925     baseColor.a *= v_color.a;
926   #endif
927 
928   #if USE_ALBEDO_MAP
929     vec4 texColor = texture2D(albedoMap, options([v_uv, v_uv1]));
930     texColor.rgb = SRGBToLinear(texColor.rgb);
931     baseColor *= texColor;
932   #endif
933 
934   s.albedo = baseColor;
935   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
936 
937   #if USE_ALPHA_TEST
938     alphaTestFunc(s.albedo.options([a, r]));
939   #endif
940 
941   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
942     vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);
943     s.lightmap = UnpackLightingmap(lightColor);
944     s.lightmap_test = v_luv.z; 
945   #endif
946 
947   s.normal = v_normal;
948   #if USE_NORMAL_MAP
949     vec3 nmmp = texture2D(normalMap, options([v_uv, v_uv1])).xyz - vec3(0.5);
950     s.normal =
951       (nmmp.x * miscParams.x) * normalize(v_tangent) +
952       (nmmp.y * miscParams.x) * normalize(v_bitangent) +
953       nmmp.z * normalize(s.normal);
954   #endif
955 
956   s.position = v_position;
957 
958   vec4 pbr = pbrParams;
959   #if USE_PBR_MAP
960     vec4 res = texture2D(pbrMap, options([v_uv, v_uv1]));
961     pbr.x *= res.OCCLUSION_CHANNEL;
962     pbr.y *= res.ROUGHNESS_CHANNEL;
963     pbr.z *= res.METALLIC_CHANNEL;
964     pbr.w *= res.SPECULARINTENSITY_CHANNEL;
965   #endif
966 
967   #if USE_METALLIC_ROUGHNESS_MAP
968     vec4 metallicRoughness = texture2D(metallicRoughnessMap, options([v_uv, v_uv1]));
969     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
970     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
971   #endif
972 
973   #if USE_OCCLUSION_MAP
974     pbr.x *= texture2D(occlusionMap, options([v_uv, v_uv1])).OCCLUSION_CHANNEL;
975   #endif
976   s.occlusion = clamp(pbr.x, 0.0, 0.96);
977   s.roughness = clamp(pbr.y, 0.04, 1.0);
978   s.metallic = pbr.z;
979 
980   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
981   #if USE_EMISSIVE_MAP
982     s.emissive *= SRGBToLinear(texture2D(emissiveMap, options([v_uv, v_uv1])).rgb);
983   #endif
984 
985   #if USE_ANISOTROPY
986     vec2 anisoUV = v_uv * anisoTile.xy + anisoTile.zw;
987     vec4 anisoMap = texture2D(anisoRamp, anisoUV);
988     float jitterFactor = anisoMap.r * anisoJitter.x + anisoMap.g * anisoJitter.y;
989     float aoFactor = mix(1.0, 0.0, anisoAOStrength * pbr.x);
990 
991     vec4 hairSpec = clamp((anisotropyIndex(hairSpecMOffset, jitterFactor, hairSpecMAmt) * hairSpecColor01 * hairSpecIntensity + anisotropyIndex(hairSpecAOffset, jitterFactor, hairSpecAAmt) * hairSpecColor02 * hairSpecIntensity) *
992                           aoFactor *
993                           pow((1.0 - dot(v_normal, worldViewDir.xyz)), 2.25),
994                           0.0, 1.51);
995 
996     s.albedo.rgb += hairBaseColor.rgb + hairSpec.rgb;
997   #endif
998 }
999 
1000 
1001 #if CC_FORWARD_ADD                                                 
1002                                
1003                                
1004                                
1005   #if CC_PIPELINE_TYPE == 0                             
1006     #define LIGHTS_PER_PASS 1                             
1007   #else                             
1008     #define LIGHTS_PER_PASS 10                             
1009   #endif                             
1010                                
1011   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1012   uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];
1013   uniform vec4 cc_lightColor[LIGHTS_PER_PASS];
1014   uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];
1015   uniform vec4 cc_lightDir[LIGHTS_PER_PASS];
1016                              
1017   #endif                             
1018                                
1019                                
1020                                
1021                                
1022   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {                             
1023     float factor = distSqr * invSqrAttRadius;                             
1024     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);                             
1025     return smoothFactor * smoothFactor;                             
1026   }                             
1027                                
1028   float GetDistAtt (float distSqr, float invSqrAttRadius) {                             
1029     float attenuation = 1.0 / max(distSqr, 0.01*0.01);                             
1030     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);                             
1031     return attenuation;                             
1032   }                             
1033                                
1034   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {                             
1035     float cd = dot(litDir, L);                             
1036     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);                             
1037     return (attenuation * attenuation);                             
1038   }                             
1039                                
1040                                
1041   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1042   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {                             
1043     vec3 position;                             
1044     
1045     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1046     position = unpackHighpData(s.position, s.position_fract_part);
1047     #else
1048     position = s.position;
1049     #endif
1050     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                             
1051     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                             
1052     vec3 diffuseContrib = diffuse / PI;                             
1053                                
1054     vec3 N = normalize(s.normal);                             
1055     vec3 V = normalize(cc_cameraPos.xyz - position);                             
1056     float NV = max(abs(dot(N, V)), 0.0);                             
1057     specular = BRDFApprox(specular, s.roughness, NV);                             
1058     vec3 finalColor = vec3(0.0);                             
1059                                
1060     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);                             
1061                                
1062     for (int i = 0; i < LIGHTS_PER_PASS; i++) {                             
1063       if (i >= numLights) break;                             
1064       vec3 SLU = cc_lightPos[i].xyz - position;                             
1065       vec3 SL = normalize(SLU);                             
1066       vec3 SH = normalize(SL + V);                             
1067       float SNL = max(dot(N, SL), 0.0);                             
1068       float SNH = max(dot(N, SH), 0.0);                             
1069                                
1070       float distSqr = dot(SLU, SLU);                             
1071       float litRadius = cc_lightSizeRangeAngle[i].x;                             
1072       float litRadiusSqr = litRadius * litRadius;                             
1073       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);                             
1074       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);                             
1075       attRadiusSqrInv *= attRadiusSqrInv;                             
1076       float att = GetDistAtt(distSqr, attRadiusSqrInv);                             
1077       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                             
1078                                
1079       if (cc_lightPos[i].w > 0.0) {                             
1080         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);                             
1081         float cosOuter = cc_lightSizeRangeAngle[i].z;                             
1082         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                             
1083         float litAngleOffset = -cosOuter * litAngleScale;                             
1084         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);                             
1085       }                             
1086                                
1087       vec3 lightColor = cc_lightColor[i].rgb;                             
1088                                
1089       float shadow = 1.0;                             
1090       #if CC_RECEIVE_SHADOW                             
1091         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {                             
1092           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                             
1093         }                             
1094       #endif                             
1095                                
1096       lightColor *= shadow;                             
1097       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);                             
1098     }                             
1099                                
1100     return vec4(finalColor, 0.0);                             
1101   }                             
1102   #endif                             
1103                                
1104   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                       
1105   readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };                              
1106   readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };                              
1107   readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };                              
1108                                 
1109   struct CCLight                              
1110   {                              
1111     vec4 cc_lightPos;                              
1112     vec4 cc_lightColor;                              
1113     vec4 cc_lightSizeRangeAngle;                              
1114     vec4 cc_lightDir;                              
1115   };                              
1116                                 
1117   struct Cluster                              
1118   {                              
1119     vec3 minBounds;                              
1120     vec3 maxBounds;                              
1121   };                              
1122                                 
1123   struct LightGrid                              
1124   {                              
1125     uint offset;                              
1126     uint ccLights;                              
1127   };                              
1128                                 
1129                                 
1130                                 
1131   CCLight getCCLight(uint i)                              
1132   {                              
1133     CCLight light;                              
1134     light.cc_lightPos = b_ccLights[4u * i + 0u];                              
1135     light.cc_lightColor = b_ccLights[4u * i + 1u];                              
1136     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];                              
1137     light.cc_lightDir = b_ccLights[4u * i + 3u];                              
1138     return light;                              
1139   }                              
1140                                 
1141   LightGrid getLightGrid(uint cluster)                              
1142   {                              
1143     uvec4 gridvec = b_clusterLightGrid[cluster];                              
1144     LightGrid grid;                              
1145     grid.offset = gridvec.x;                              
1146     grid.ccLights = gridvec.y;                              
1147     return grid;                              
1148   }                              
1149                                 
1150   uint getGridLightIndex(uint start, uint offset)                              
1151   {                              
1152     return b_clusterLightIndices[start + offset];                              
1153   }                              
1154                                 
1155   uint getClusterZIndex(vec4 worldPos)                              
1156   {                              
1157     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);                              
1158     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));                              
1159     float eyeDepth = -(cc_matView * worldPos).z;                              
1160     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));                              
1161     return zIndex;                              
1162   }                              
1163                                 
1164   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)                              
1165   {                              
1166     uint zIndex = getClusterZIndex(worldPos);                              
1167     float clusterSizeX = ceil(cc_viewPort.z / float(16));                              
1168     float clusterSizeY = ceil(cc_viewPort.w / float(8));                              
1169     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);                              
1170     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;                              
1171     return cluster;                              
1172   }                              
1173                                 
1174   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {                              
1175     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                              
1176     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                              
1177     vec3 diffuseContrib = diffuse / PI;                              
1178                                 
1179     vec3 position;                              
1180     
1181     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1182     position = unpackHighpData(s.position, s.position_fract_part);
1183     #else
1184     position = s.position;
1185     #endif
1186                                 
1187     vec3 N = normalize(s.normal);                              
1188     vec3 V = normalize(cc_cameraPos.xyz - position);                              
1189     float NV = max(abs(dot(N, V)), 0.001);                              
1190     specular = BRDFApprox(specular, s.roughness, NV);                              
1191     vec3 finalColor = vec3(0.0);                              
1192                                 
1193     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));                              
1194     LightGrid grid = getLightGrid(cluster);                              
1195     uint numLights = grid.ccLights;                              
1196                                 
1197     for (uint i = 0u; i < 100u; i++) {                              
1198       if (i >= numLights) break;                              
1199       uint lightIndex = getGridLightIndex(grid.offset, i);                              
1200       CCLight light = getCCLight(lightIndex);                              
1201       vec3 SLU = light.cc_lightPos.xyz - position;                              
1202       vec3 SL = normalize(SLU);                              
1203       vec3 SH = normalize(SL + V);                              
1204       float SNL = max(dot(N, SL), 0.001);                              
1205       float SNH = max(dot(N, SH), 0.0);                              
1206                                 
1207       float distSqr = dot(SLU, SLU);                              
1208       float litRadius = light.cc_lightSizeRangeAngle.x;                              
1209       float litRadiusSqr = litRadius * litRadius;                              
1210       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));                              
1211       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);                              
1212       attRadiusSqrInv *= attRadiusSqrInv;                              
1213       float att = GetDistAtt(distSqr, attRadiusSqrInv);                              
1214       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                              
1215                                 
1216       if (light.cc_lightPos.w > 0.0) {                              
1217         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);                              
1218         float cosOuter = light.cc_lightSizeRangeAngle.z;                              
1219         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                              
1220         float litAngleOffset = -cosOuter * litAngleScale;                              
1221         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);                              
1222       }                              
1223                                 
1224       vec3 lightColor = light.cc_lightColor.rgb;                              
1225                                 
1226       float shadow = 1.0;                              
1227       #if CC_RECEIVE_SHADOW                              
1228         if (light.cc_lightPos.w > 0.0) {                              
1229           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                              
1230         }                              
1231       #endif                              
1232                                 
1233       lightColor *= shadow;                              
1234       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);                              
1235     }                              
1236                                 
1237     return vec4(finalColor, 0.0);                              
1238   }                              
1239                                 
1240   #endif                                                           
1241                                                                    
1242                           
1243                                                                    
1244   void main () {                                                   
1245     StandardSurface s; surf(s);                                    
1246     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                     
1247     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);  
1248     #else                                                          
1249     vec4 color = CCStandardShadingAdditive(s, v_shadowPos); 
1250     #endif                                                         
1251     gl_FragData[0] = CCFragOutput(color);                              
1252   }                                                                
1253                                                                    
1254 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING) 
1255                                                                    
1256                           
1257                                                                    
1258   void main () {                                                   
1259     StandardSurface s; surf(s);                                    
1260     vec4 color = CCStandardShadingBase(s, v_shadowPos);     
1261     CC_APPLY_FOG(color, s.position.xyz);                           
1262     gl_FragData[0] = CCFragOutput(color);                              
1263   }                                                                
1264                                                                    
1265 #elif CC_PIPELINE_TYPE == 1                
1266                                     
1267   vec2 signNotZero(vec2 v) {                                  
1268     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);                                  
1269   }                                  
1270   vec2 float32x3_to_oct(in vec3 v) {                                  
1271     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));                                  
1272     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;                                  
1273   }                                  
1274                                     
1275                                     
1276                                     
1277                                     
1278                                                                    
1279                           
1280                           
1281                           
1282                                                                    
1283   void main () {                                                   
1284     StandardSurface s; surf(s);                                    
1285     gl_FragData[0] = s.albedo;                                         
1286     gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic); 
1287     gl_FragData[2] = vec4(s.emissive, s.occlusion);                    
1288   }                                                                
1289                                                                    
1290 #endif                                                             
1291 [Asset DB] ../test/builtin-standard-anisotropy-001.effect - standard-fs: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:929: '[' : syntax error
 

1 #version 100
2 #define USE_INSTANCING 1
3 #define USE_BATCHING 1
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
13 #define CC_USE_SKINNING 1
14 #define CC_USE_BAKED_ANIMATION 1
15 #define USE_LIGHTMAP 1
16 #define CC_RECEIVE_SHADOW 1
17 #define CC_USE_MORPH 1
18 #define CC_MORPH_TARGET_COUNT 2
19 #define CC_MORPH_PRECOMPUTED 1
20 #define CC_MORPH_TARGET_HAS_POSITION 1
21 #define CC_MORPH_TARGET_HAS_NORMAL 1
22 #define CC_MORPH_TARGET_HAS_TANGENT 1
23 #define CC_USE_FOG 0
24 #define CC_USE_ACCURATE_FOG 1
25 #define USE_VERTEX_COLOR 1
26 #define HAS_SECOND_UV 1
27 #define CC_FORWARD_ADD 1
28 #define USE_NORMAL_MAP 1
29 #define SAMPLE_FROM_RT 1
30 #define CC_USE_IBL 0
31 #define CC_USE_DIFFUSEMAP 0
32 #define USE_REFLECTION_DENOISE 1
33 #define CC_USE_HDR 1
34 #define USE_ALBEDO_MAP 1
35 #define USE_PBR_MAP 1
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define USE_OCCLUSION_MAP 1
38 #define USE_EMISSIVE_MAP 1
39 #define USE_ALPHA_TEST 1
40 #define USE_ANISOTROPY 1
41 #define CC_PIPELINE_TYPE 0
42 #define CC_FORCE_FORWARD_SHADING 1
43 
44 #ifdef GL_EXT_draw_buffers
45 #extension GL_EXT_draw_buffers: enable
46 #endif
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp mat4 cc_matView;
58   uniform highp vec4 cc_cameraPos;
59   uniform mediump vec4 cc_mainLitDir;
60   uniform mediump vec4 cc_mainLitColor;
61   uniform mediump vec4 cc_ambientSky;
62   uniform mediump vec4 cc_ambientGround;
63   uniform mediump vec4 cc_fogColor;
64   uniform mediump vec4 cc_fogBase;
65   uniform mediump vec4 cc_fogAdd;
66   uniform mediump vec4 cc_nearFar;
67   uniform mediump vec4 cc_viewPort;
68 
69 
70 
71      uniform vec4 albedo;
72      uniform vec4 albedoScaleAndCutoff;
73      uniform vec4 pbrParams;
74      uniform vec4 miscParams;
75      uniform vec4 emissive;
76      uniform vec4 emissiveScaleParam;
77      uniform vec4 anisoTile;
78      uniform vec4 hairBaseColor;
79      uniform vec4 hairSpecColor01;
80      uniform vec4 hairSpecColor02;
81      uniform vec2 anisoJitter;
82      uniform float anisoAOStrength;
83      uniform float hairSpecMOffset;
84      uniform float hairSpecAOffset;
85      uniform float hairSpecMAmt;
86      uniform float hairSpecAAmt;
87      uniform float hairSpecIntensity;
88 
89 float LinearFog(vec4 pos) {
90   vec4 wPos = pos;
91   float cam_dis = distance(cc_cameraPos, wPos);
92   float fogStart = cc_fogBase.x;
93   float fogEnd = cc_fogBase.y;
94   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);
95 }
96 
97 float ExpFog(vec4 pos) {
98   vec4 wPos = pos;
99   float fogAtten = cc_fogAdd.z;
100   float fogStart = cc_fogBase.x;
101   float fogDensity = cc_fogBase.z;
102   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
103   float f = exp(-cam_dis * fogDensity);
104   return f;
105 }
106 
107 float ExpSquaredFog(vec4 pos) {
108   vec4 wPos = pos;
109   float fogAtten = cc_fogAdd.z;
110   float fogStart = cc_fogBase.x;
111   float fogDensity = cc_fogBase.z;
112   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
113   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);
114   return f;
115 }
116 
117 float LayeredFog(vec4 pos) {
118   vec4 wPos = pos;
119   float fogAtten = cc_fogAdd.z;
120   float _FogTop = cc_fogAdd.x;
121   float _FogRange = cc_fogAdd.y;
122   vec3 camWorldProj = cc_cameraPos.xyz;
123   camWorldProj.y = 0.;
124   vec3 worldPosProj = wPos.xyz;
125   worldPosProj.y = 0.;
126   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;
127   float fDeltaY, fDensityIntegral;
128   if (cc_cameraPos.y > _FogTop) {
129     if (wPos.y < _FogTop) {
130       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;
131       fDensityIntegral = fDeltaY * fDeltaY * 0.5;
132     } else {
133       fDeltaY = 0.;
134       fDensityIntegral = 0.;
135     }
136   } else {
137     if (wPos.y < _FogTop) {
138       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;
139       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;
140       fDeltaY = abs(fDeltaA - fDeltaB);
141       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));
142     } else {
143       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;
144       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);
145     }
146   }
147   float fDensity;
148   if (fDeltaY != 0.) {
149     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;
150   } else {
151     fDensity = 0.;
152   }
153   float f = exp(-fDensity);
154   return f;
155 }
156 
157 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)
158 {
159   #if CC_USE_FOG == 0
160 	factor = LinearFog(pos);
161   #elif CC_USE_FOG == 1
162     factor = ExpFog(pos);
163   #elif CC_USE_FOG == 2
164     factor = ExpSquaredFog(pos);
165   #elif CC_USE_FOG == 3
166     factor = LayeredFog(pos);
167   #else
168     factor = 1.0;
169   #endif
170 }
171 
172 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {
173   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);
174 }
175 
176 
177 #if !CC_USE_ACCURATE_FOG
178 varying float v_fog_factor;
179 #endif
180 
181 void CC_APPLY_FOG(inout vec4 color) {
182 #if !CC_USE_ACCURATE_FOG
183     CC_APPLY_FOG_BASE(color, v_fog_factor);
184 #endif
185 }
186 
187 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {
188 #if CC_USE_ACCURATE_FOG
189     float factor;
190     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);
191 #else
192     float factor = v_fog_factor;
193 #endif
194     CC_APPLY_FOG_BASE(color, factor);
195 }
196 
197 vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
198   
199     #ifdef GL_EXT_shader_texture_lod
200       return texture2DLodEXT(tex, coord, lod);
201     #else
202       return texture2D(tex, coord, lod);
203     #endif
204   
205 }
206 
207 vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
208   
209     #ifdef GL_EXT_shader_texture_lod
210       return textureCubeLodEXT(tex, coord, lod);
211     #else
212       return textureCube(tex, coord, lod);
213     #endif
214   
215 }
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 #define QUATER_PI         0.78539816340
228 #define HALF_PI           1.57079632679
229 #define PI                3.14159265359
230 #define PI2               6.28318530718
231 #define PI4               12.5663706144
232      
233 #define INV_QUATER_PI     1.27323954474
234 #define INV_HALF_PI       0.63661977237
235 #define INV_PI            0.31830988618
236 #define INV_PI2           0.15915494309
237 #define INV_PI4           0.07957747155
238      
239 #define EPSILON           1e-6
240 #define EPSILON_LOWP      1e-4
241 #define LOG2              1.442695
242 #define EXP_VALUE         2.71828183f
243 #define FP_MAX            65504.0
244 #define FP_SCALE          0.0009765625
245 #define FP_SCALE_INV      1024.0
246 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
247 
248 
249 
250 
251 
252 
253 
254 vec3 SRGBToLinear (vec3 gamma) {
255   return gamma * gamma;
256 }
257 uniform highp mat4 cc_matLightView;
258   uniform highp vec4 cc_shadowInvProjDepthInfo;
259   uniform highp vec4 cc_shadowProjDepthInfo;
260   uniform highp vec4 cc_shadowProjInfo;
261   uniform mediump vec4 cc_shadowNFLSInfo;
262   uniform mediump vec4 cc_shadowWHPBInfo;
263   uniform mediump vec4 cc_shadowLPNNInfo;
264 
265 
266 
267 
268 
269 
270 
271 
272 highp float unpackHighpData (float mainPart, float modPart) {
273   highp float data = mainPart;
274   return data + modPart;
275 }
276 
277 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
278   highp float data = mainPart * modValue;
279   return data + modPart * modValue;
280 }
281 
282 
283 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
284   highp vec2 data = mainPart;
285   return data + modPart;
286 }
287 
288 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
289   highp vec2 data = mainPart * modValue;
290   return data + modPart * modValue;
291 }
292 
293 
294 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
295   highp vec3 data = mainPart;
296   return data + modPart;
297 }
298 
299 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
300   highp vec3 data = mainPart * modValue;
301   return data + modPart * modValue;
302 }
303 
304 
305 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
306   highp vec4 data = mainPart;
307   return data + modPart;
308 }
309 
310 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
311   highp vec4 data = mainPart * modValue;
312   return data + modPart * modValue;
313 }
314 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {
315   float dist = length(viewPos);
316   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);
317 }
318 
319 float CCGetLinearDepth(vec3 worldPos) {
320   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);
321   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);
322 }
323 
324 
325 
326 #if CC_RECEIVE_SHADOW
327   uniform highp sampler2D cc_shadowMap;
328   uniform highp sampler2D cc_spotLightingMap;
329 
330   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
331   {
332     vec4 newShadowPos = shadowPos;
333     if(normalBias > EPSILON_LOWP)
334     {
335       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
336       if(viewNormal.z < 0.1)
337         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
338     }
339     return newShadowPos;
340   }
341   
342   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)
343   {
344     vec3 viewSpacePos;
345     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;
346     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;
347     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;
348     vec4 clipSpacePos;
349     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;
350     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);
351     if (cc_shadowNFLSInfo.z > EPSILON) {
352       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);
353       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;
354     }
355 
356     return clipSpacePos;
357   }
358 
359   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
360   {
361     float coeffA = cc_shadowProjDepthInfo.x;
362     float coeffB = cc_shadowProjDepthInfo.y;
363     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
364     viewSpacePos_z += viewspaceDepthBias;
365     vec4 result = shadowPos;
366     result.z = viewSpacePos_z * coeffA + coeffB;
367     return result;
368   }
369   
370   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
371     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
372     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
373     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
374         clipPos.y < 0.0 || clipPos.y > 1.0 ||
375         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
376     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
377 
378     float shadow = 0.0;
379     float closestDepth = 0.0;
380     if (cc_shadowLPNNInfo.y > EPSILON) {
381       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
382     } else {
383       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
384     }
385     shadow = step(clipPos.z, closestDepth);
386 
387     return shadow;
388   }
389 
390   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
391     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
392     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
393     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
394         clipPos.y < 0.0 || clipPos.y > 1.0 ||
395         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
396     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
397 
398     float offsetDepth = clipPos.z;
399     vec2 mapSize = cc_shadowWHPBInfo.xy;
400     vec2 oneTap = 1.0 / mapSize;
401     vec2 clipPos_offset = clipPos.xy + oneTap;
402 
403     float block0, block1, block2, block3;
404     if (cc_shadowLPNNInfo.y > EPSILON) {
405       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
406       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
407       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
408       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
409     } else {
410       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
411       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
412       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
413       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
414     }
415 
416     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
417     float resultX = mix(block0, block1, coefX);
418     float resultY = mix(block2, block3, coefX);
419     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
420 
421     return mix(resultX, resultY, coefY);
422   }
423 
424   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
425     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
426     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
427     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
428         clipPos.y < 0.0 || clipPos.y > 1.0 ||
429         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
430     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
431 
432     float offsetDepth = clipPos.z;
433     vec2 mapSize = cc_shadowWHPBInfo.xy;
434     vec2 oneTap = 1.0 / mapSize;
435     float clipPos_offset_L = clipPos.x - oneTap.x;
436     float clipPos_offset_R = clipPos.x + oneTap.x;
437     float clipPos_offset_U = clipPos.y - oneTap.y;
438     float clipPos_offset_D = clipPos.y + oneTap.y;
439 
440     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
441     if (cc_shadowLPNNInfo.y > EPSILON) {
442       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
443       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
444       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
445       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
446       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
447       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
448       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
449       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
450       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
451     } else {
452       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
453       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
454       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
455       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
456       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
457       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
458       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
459       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
460       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
461     }
462 
463     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
464     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
465 
466     float shadow = 0.0;
467     float resultX = mix(block0, block1, coefX);
468     float resultY = mix(block3, block4, coefX);
469     shadow += mix(resultX , resultY, coefY);
470 
471     resultX = mix(block1, block2, coefX);
472     resultY = mix(block4, block5, coefX);
473     shadow += mix(resultX , resultY, coefY);
474 
475     resultX = mix(block3, block4, coefX);
476     resultY = mix(block6, block7, coefX);
477     shadow += mix(resultX, resultY, coefY);
478 
479     resultX = mix(block4, block5, coefX);
480     resultY = mix(block7, block8, coefX);
481     shadow += mix(resultX, resultY, coefY);
482 
483     return shadow * 0.25;
484   }
485 
486   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {
487     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
488     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
489     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
490         clipPos.y < 0.0 || clipPos.y > 1.0 ||
491         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
492     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
493 
494     float shadow = 0.0;
495     float closestDepth = 0.0;
496     float depth = clipPos.z;
497 
498     if (cc_shadowLPNNInfo.y > EPSILON) {
499       closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
500     } else {
501       closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;
502     }
503     shadow = step(depth, closestDepth);
504 
505     return shadow;
506   }
507 
508   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {
509     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
510     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
511     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
512         clipPos.y < 0.0 || clipPos.y > 1.0 ||
513         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
514     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
515 
516     float depth = 0.0;
517     if (cc_shadowNFLSInfo.z > EPSILON) {
518       depth = CCGetLinearDepth(worldPos);
519     } else {
520       depth = clipPos.z;
521     }
522 
523     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;
524     vec2 clipPos_offset = clipPos.xy + oneTap;
525 
526     float block0, block1, block2, block3;
527     if (cc_shadowLPNNInfo.y > EPSILON) {
528       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
529       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
530       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
531       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
532     } else {
533       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
534       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);
535       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);
536       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
537     }
538 
539     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;
540     float resultX = mix(block0, block1, coefX);
541     float resultY = mix(block2, block3, coefX);
542     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;
543 
544     return mix(resultX, resultY, coefY);
545   }
546 
547   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {
548     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
549     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
550     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
551         clipPos.y < 0.0 || clipPos.y > 1.0 ||
552         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
553     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
554 
555     float depth = 0.0;
556     if (cc_shadowNFLSInfo.z > EPSILON) {
557       depth = CCGetLinearDepth(worldPos);
558     } else {
559       depth = clipPos.z;
560     }
561 
562     vec2 mapSize = cc_shadowWHPBInfo.xy;
563     vec2 oneTap = 1.0 / mapSize;
564     float clipPos_offset_L = clipPos.x - oneTap.x;
565     float clipPos_offset_R = clipPos.x + oneTap.x;
566     float clipPos_offset_U = clipPos.y - oneTap.y;
567     float clipPos_offset_D = clipPos.y + oneTap.y;
568 
569     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
570     if (cc_shadowLPNNInfo.y > EPSILON) {
571       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
572       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
573       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
574       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
575       block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
576       block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
577       block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
578       block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
579       block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
580     } else {
581       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
582       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);
583       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
584       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);
585       block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
586       block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);
587       block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
588       block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);
589       block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
590     }
591 
592     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
593     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
594 
595     float shadow = 0.0;
596     float resultX = mix(block0, block1, coefX);
597     float resultY = mix(block3, block4, coefX);
598     shadow += mix(resultX , resultY, coefY);
599 
600     resultX = mix(block1, block2, coefX);
601     resultY = mix(block4, block5, coefX);
602     shadow += mix(resultX , resultY, coefY);
603 
604     resultX = mix(block3, block4, coefX);
605     resultY = mix(block6, block7, coefX);
606     shadow += mix(resultX, resultY, coefY);
607 
608     resultX = mix(block4, block5, coefX);
609     resultY = mix(block7, block8, coefX);
610     shadow += mix(resultX, resultY, coefY);
611 
612     return shadow * 0.25;
613   }
614 
615 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
616 {
617   float pcf = cc_shadowWHPBInfo.z;
618   if (pcf > 1.9) { 
619     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);
620   }else if (pcf > 0.9) { 
621     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);
622   }else { 
623     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x); 
624   }
625 }
626 
627 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
628 {
629   float realtimeShadow = 1.0;
630   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
631   
632   float pcf = cc_shadowWHPBInfo.z;
633   if (pcf > 1.9) { 
634     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
635   }else if (pcf > 0.9) {
636     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
637   }else { 
638     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
639   }
640   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
641 }
642 #endif
643 
644 
645 
646 #if CC_USE_IBL
647   uniform samplerCube cc_environment;
648   
649 
650   
651   
652   vec3 unpackRGBE (vec4 rgbe) {
653     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
654   }
655   
656 
657   #if CC_USE_DIFFUSEMAP
658     uniform samplerCube cc_diffuseMap;
659   #endif
660 #endif
661 
662 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
663   vec3 NxH = cross(N, H);
664   float OneMinusNoHSqr = dot(NxH, NxH);
665   float a = roughness * roughness;
666   float n = NoH * a;
667   float p = a / (OneMinusNoHSqr + n * n);
668   return p * p;
669 }
670 
671 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
672   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
673 }
674 
675 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
676   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
677   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
678   vec4 r = roughness * c0 + c1;
679   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
680   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
681   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
682   return specular * AB.x + AB.y;
683 }
684 
685 #if USE_REFLECTION_DENOISE
686   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
687     #if CC_USE_IBL
688     	float mip = roughness * mipCount;
689     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
690     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
691 
692     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
693      	vec4 filtered = textureCube(cc_environment, R);
694 
695       #if CC_USE_IBL == 2
696       	biased.rgb = unpackRGBE(biased);
697       	filtered.rgb = unpackRGBE(filtered);
698       #else
699       	biased.rgb = SRGBToLinear(biased.rgb);
700       	filtered.rgb = SRGBToLinear(filtered.rgb);
701       #endif
702       	
703       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
704     #else
705       return vec3(0.0, 0.0, 0.0);
706     #endif
707   }
708 #endif
709 
710 
711 struct StandardSurface {
712   vec4 albedo;
713   
714   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
715   vec3 position, position_fract_part;
716   #else
717   vec3 position;
718   #endif
719   vec3 normal;
720   vec3 emissive;
721   vec3 lightmap;
722   float lightmap_test;
723   float roughness;
724   float metallic;
725   float occlusion;
726   float specularIntensity;
727 
728   #if CC_RECEIVE_SHADOW
729     vec2 shadowBias;
730   #endif
731 };
732 
733 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
734   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
735  
736   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
737 
738   vec3 position;
739   
740   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
741   position = unpackHighpData(s.position, s.position_fract_part);
742   #else
743   position = s.position;
744   #endif
745 
746   vec3 N = normalize(s.normal);
747   vec3 V = normalize(cc_cameraPos.xyz - position);
748 
749   float NV = max(abs(dot(N, V)), 0.0);
750   specular = BRDFApprox(specular, s.roughness, NV);
751 
752   vec3 L = normalize(-cc_mainLitDir.xyz);
753   vec3 H = normalize(L + V);
754   float NH = max(dot(N, H), 0.0);
755   float NL = max(dot(N, L), 0.0);
756   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
757   vec3 diffuseContrib = diffuse / PI;
758   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
759   vec3 dirlightContrib = (diffuseContrib + specularContrib);
760 
761   float shadow = 1.0;
762   #if CC_RECEIVE_SHADOW
763     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
764       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
765     }
766   #endif
767 
768   dirlightContrib *= shadow;
769   finalColor *= dirlightContrib;
770 
771   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
772     if (s.lightmap_test > EPSILON_LOWP) {
773       finalColor = diffuse * s.lightmap.rgb * shadow;
774     }
775   #endif
776 
777   float fAmb = 0.5 - N.y * 0.5;
778   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
779 
780 
781   #if CC_USE_IBL
782     #if CC_USE_DIFFUSEMAP
783       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
784       #if CC_USE_DIFFUSEMAP == 2
785         ambDiff = unpackRGBE(diffuseMap);
786       #else
787         ambDiff = SRGBToLinear(diffuseMap.rgb);
788       #endif
789     #endif
790 
791     vec3 R = normalize(reflect(-V, N));
792 
793     #if USE_REFLECTION_DENOISE
794       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
795     #else
796       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
797 
798       #if CC_USE_IBL == 2
799         vec3 env = unpackRGBE(envmap);
800       #else
801         vec3 env = SRGBToLinear(envmap.rgb);
802       #endif
803     #endif
804 
805     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
806   #endif
807 
808   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
809   
810 
811   finalColor += s.emissive;
812 
813   return vec4(finalColor, s.albedo.a);
814 }
815 
816 
817 
818 vec3 ACESToneMap (vec3 color) {
819   color = min(color, vec3(8.0));
820   const float A = 2.51;
821   const float B = 0.03;
822   const float C = 2.43;
823   const float D = 0.59;
824   const float E = 0.14;
825   return (color * (A * color + B)) / (color * (C * color + D) + E);
826 }
827 
828 
829 
830 vec4 CCFragOutput (vec4 color) {
831   #if CC_USE_HDR
832     color.rgb = ACESToneMap(color.rgb);
833   #endif
834   color.rgb = sqrt(color.rgb);
835   return color;
836 }
837 
838 
839 
840 
841 varying highp vec4 v_shadowPos;
842 
843 
844 
845 #if CC_RECEIVE_SHADOW
846 
847 
848 
849 #endif
850 
851 
852 
853 
854 #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
855   varying vec3 v_luv;
856   uniform sampler2D cc_lightingMap;
857   
858 #endif
859 
860 void alphaTestFunc(float alpha)
861 {
862   if (alpha < albedoScaleAndCutoff.w) discard;
863 }
864 
865 
866 varying vec3 v_position;
867 varying vec2 v_uv;
868 varying vec2 v_uv1;
869 varying vec3 v_normal;
870 varying vec3 v_tangent;
871 varying vec3 v_bitangent;
872 
873 varying vec4 worldViewDir;
874 varying vec4 worldHalfDir;
875 
876 #if USE_VERTEX_COLOR
877   varying vec4 v_color;
878 #endif
879 
880 #if USE_ALBEDO_MAP
881   uniform sampler2D albedoMap;
882   #endif
883 #if USE_NORMAL_MAP
884   uniform sampler2D normalMap;
885   #endif
886 #if USE_PBR_MAP
887   uniform sampler2D pbrMap;
888 #endif
889 #if USE_METALLIC_ROUGHNESS_MAP
890   uniform sampler2D metallicRoughnessMap;
891 #endif
892 #if USE_OCCLUSION_MAP
893   uniform sampler2D occlusionMap;
894 #endif
895 #if USE_EMISSIVE_MAP
896   uniform sampler2D emissiveMap;
897   #endif
898 
899 #define OCCLUSION_CHANNEL r
900 #define ROUGHNESS_CHANNEL g
901 #define METALLIC_CHANNEL  b
902 #define SPECULARINTENSITY_CHANNEL w
903 
904 
905 #if USE_ALPHA_TEST
906   #endif
907 
908 #if USE_ANISOTROPY
909   uniform sampler2D anisoRamp;
910 #endif
911 
912 float anisotropyIndex( float offset, float factor, float amt ) {
913   vec3 jitterN = v_bitangent + (v_normal * offset + factor);
914   float NHdot = dot(normalize(jitterN), normalize(worldHalfDir.xyz));
915   float sinNH = max(0.01, sqrt(1.0 - pow(NHdot, 2.0)));
916   float atten = smoothstep(-1.0, 0.0, NHdot);
917   return pow(sinNH, amt) * atten;
918 }
919 
920 void surf (out StandardSurface s) {
921   vec4 baseColor = albedo;
922 
923   #if USE_VERTEX_COLOR
924     baseColor.rgb *= SRGBToLinear(v_color.rgb);
925     baseColor.a *= v_color.a;
926   #endif
927 
928   #if USE_ALBEDO_MAP
929     vec4 texColor = texture2D(albedoMap, options([v_uv, v_uv1]));
930     texColor.rgb = SRGBToLinear(texColor.rgb);
931     baseColor *= texColor;
932   #endif
933 
934   s.albedo = baseColor;
935   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
936 
937   #if USE_ALPHA_TEST
938     alphaTestFunc(s.albedo.options([a, r]));
939   #endif
940 
941   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
942     vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);
943     s.lightmap = UnpackLightingmap(lightColor);
944     s.lightmap_test = v_luv.z; 
945   #endif
946 
947   s.normal = v_normal;
948   #if USE_NORMAL_MAP
949     vec3 nmmp = texture2D(normalMap, options([v_uv, v_uv1])).xyz - vec3(0.5);
950     s.normal =
951       (nmmp.x * miscParams.x) * normalize(v_tangent) +
952       (nmmp.y * miscParams.x) * normalize(v_bitangent) +
953       nmmp.z * normalize(s.normal);
954   #endif
955 
956   s.position = v_position;
957 
958   vec4 pbr = pbrParams;
959   #if USE_PBR_MAP
960     vec4 res = texture2D(pbrMap, options([v_uv, v_uv1]));
961     pbr.x *= res.OCCLUSION_CHANNEL;
962     pbr.y *= res.ROUGHNESS_CHANNEL;
963     pbr.z *= res.METALLIC_CHANNEL;
964     pbr.w *= res.SPECULARINTENSITY_CHANNEL;
965   #endif
966 
967   #if USE_METALLIC_ROUGHNESS_MAP
968     vec4 metallicRoughness = texture2D(metallicRoughnessMap, options([v_uv, v_uv1]));
969     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
970     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
971   #endif
972 
973   #if USE_OCCLUSION_MAP
974     pbr.x *= texture2D(occlusionMap, options([v_uv, v_uv1])).OCCLUSION_CHANNEL;
975   #endif
976   s.occlusion = clamp(pbr.x, 0.0, 0.96);
977   s.roughness = clamp(pbr.y, 0.04, 1.0);
978   s.metallic = pbr.z;
979 
980   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
981   #if USE_EMISSIVE_MAP
982     s.emissive *= SRGBToLinear(texture2D(emissiveMap, options([v_uv, v_uv1])).rgb);
983   #endif
984 
985   #if USE_ANISOTROPY
986     vec2 anisoUV = v_uv * anisoTile.xy + anisoTile.zw;
987     vec4 anisoMap = texture2D(anisoRamp, anisoUV);
988     float jitterFactor = anisoMap.r * anisoJitter.x + anisoMap.g * anisoJitter.y;
989     float aoFactor = mix(1.0, 0.0, anisoAOStrength * pbr.x);
990 
991     vec4 hairSpec = clamp((anisotropyIndex(hairSpecMOffset, jitterFactor, hairSpecMAmt) * hairSpecColor01 * hairSpecIntensity + anisotropyIndex(hairSpecAOffset, jitterFactor, hairSpecAAmt) * hairSpecColor02 * hairSpecIntensity) *
992                           aoFactor *
993                           pow((1.0 - dot(v_normal, worldViewDir.xyz)), 2.25),
994                           0.0, 1.51);
995 
996     s.albedo.rgb += hairBaseColor.rgb + hairSpec.rgb;
997   #endif
998 }
999 
1000 
1001 #if CC_FORWARD_ADD                                                 
1002                                
1003                                
1004                                
1005   #if CC_PIPELINE_TYPE == 0                             
1006     #define LIGHTS_PER_PASS 1                             
1007   #else                             
1008     #define LIGHTS_PER_PASS 10                             
1009   #endif                             
1010                                
1011   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1012   uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];
1013   uniform vec4 cc_lightColor[LIGHTS_PER_PASS];
1014   uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];
1015   uniform vec4 cc_lightDir[LIGHTS_PER_PASS];
1016                              
1017   #endif                             
1018                                
1019                                
1020                                
1021                                
1022   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {                             
1023     float factor = distSqr * invSqrAttRadius;                             
1024     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);                             
1025     return smoothFactor * smoothFactor;                             
1026   }                             
1027                                
1028   float GetDistAtt (float distSqr, float invSqrAttRadius) {                             
1029     float attenuation = 1.0 / max(distSqr, 0.01*0.01);                             
1030     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);                             
1031     return attenuation;                             
1032   }                             
1033                                
1034   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {                             
1035     float cd = dot(litDir, L);                             
1036     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);                             
1037     return (attenuation * attenuation);                             
1038   }                             
1039                                
1040                                
1041   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1042   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {                             
1043     vec3 position;                             
1044     
1045     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1046     position = unpackHighpData(s.position, s.position_fract_part);
1047     #else
1048     position = s.position;
1049     #endif
1050     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                             
1051     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                             
1052     vec3 diffuseContrib = diffuse / PI;                             
1053                                
1054     vec3 N = normalize(s.normal);                             
1055     vec3 V = normalize(cc_cameraPos.xyz - position);                             
1056     float NV = max(abs(dot(N, V)), 0.0);                             
1057     specular = BRDFApprox(specular, s.roughness, NV);                             
1058     vec3 finalColor = vec3(0.0);                             
1059                                
1060     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);                             
1061                                
1062     for (int i = 0; i < LIGHTS_PER_PASS; i++) {                             
1063       if (i >= numLights) break;                             
1064       vec3 SLU = cc_lightPos[i].xyz - position;                             
1065       vec3 SL = normalize(SLU);                             
1066       vec3 SH = normalize(SL + V);                             
1067       float SNL = max(dot(N, SL), 0.0);                             
1068       float SNH = max(dot(N, SH), 0.0);                             
1069                                
1070       float distSqr = dot(SLU, SLU);                             
1071       float litRadius = cc_lightSizeRangeAngle[i].x;                             
1072       float litRadiusSqr = litRadius * litRadius;                             
1073       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);                             
1074       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);                             
1075       attRadiusSqrInv *= attRadiusSqrInv;                             
1076       float att = GetDistAtt(distSqr, attRadiusSqrInv);                             
1077       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                             
1078                                
1079       if (cc_lightPos[i].w > 0.0) {                             
1080         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);                             
1081         float cosOuter = cc_lightSizeRangeAngle[i].z;                             
1082         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                             
1083         float litAngleOffset = -cosOuter * litAngleScale;                             
1084         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);                             
1085       }                             
1086                                
1087       vec3 lightColor = cc_lightColor[i].rgb;                             
1088                                
1089       float shadow = 1.0;                             
1090       #if CC_RECEIVE_SHADOW                             
1091         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {                             
1092           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                             
1093         }                             
1094       #endif                             
1095                                
1096       lightColor *= shadow;                             
1097       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);                             
1098     }                             
1099                                
1100     return vec4(finalColor, 0.0);                             
1101   }                             
1102   #endif                             
1103                                
1104   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                       
1105   readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };                              
1106   readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };                              
1107   readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };                              
1108                                 
1109   struct CCLight                              
1110   {                              
1111     vec4 cc_lightPos;                              
1112     vec4 cc_lightColor;                              
1113     vec4 cc_lightSizeRangeAngle;                              
1114     vec4 cc_lightDir;                              
1115   };                              
1116                                 
1117   struct Cluster                              
1118   {                              
1119     vec3 minBounds;                              
1120     vec3 maxBounds;                              
1121   };                              
1122                                 
1123   struct LightGrid                              
1124   {                              
1125     uint offset;                              
1126     uint ccLights;                              
1127   };                              
1128                                 
1129                                 
1130                                 
1131   CCLight getCCLight(uint i)                              
1132   {                              
1133     CCLight light;                              
1134     light.cc_lightPos = b_ccLights[4u * i + 0u];                              
1135     light.cc_lightColor = b_ccLights[4u * i + 1u];                              
1136     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];                              
1137     light.cc_lightDir = b_ccLights[4u * i + 3u];                              
1138     return light;                              
1139   }                              
1140                                 
1141   LightGrid getLightGrid(uint cluster)                              
1142   {                              
1143     uvec4 gridvec = b_clusterLightGrid[cluster];                              
1144     LightGrid grid;                              
1145     grid.offset = gridvec.x;                              
1146     grid.ccLights = gridvec.y;                              
1147     return grid;                              
1148   }                              
1149                                 
1150   uint getGridLightIndex(uint start, uint offset)                              
1151   {                              
1152     return b_clusterLightIndices[start + offset];                              
1153   }                              
1154                                 
1155   uint getClusterZIndex(vec4 worldPos)                              
1156   {                              
1157     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);                              
1158     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));                              
1159     float eyeDepth = -(cc_matView * worldPos).z;                              
1160     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));                              
1161     return zIndex;                              
1162   }                              
1163                                 
1164   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)                              
1165   {                              
1166     uint zIndex = getClusterZIndex(worldPos);                              
1167     float clusterSizeX = ceil(cc_viewPort.z / float(16));                              
1168     float clusterSizeY = ceil(cc_viewPort.w / float(8));                              
1169     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);                              
1170     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;                              
1171     return cluster;                              
1172   }                              
1173                                 
1174   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {                              
1175     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                              
1176     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                              
1177     vec3 diffuseContrib = diffuse / PI;                              
1178                                 
1179     vec3 position;                              
1180     
1181     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1182     position = unpackHighpData(s.position, s.position_fract_part);
1183     #else
1184     position = s.position;
1185     #endif
1186                                 
1187     vec3 N = normalize(s.normal);                              
1188     vec3 V = normalize(cc_cameraPos.xyz - position);                              
1189     float NV = max(abs(dot(N, V)), 0.001);                              
1190     specular = BRDFApprox(specular, s.roughness, NV);                              
1191     vec3 finalColor = vec3(0.0);                              
1192                                 
1193     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));                              
1194     LightGrid grid = getLightGrid(cluster);                              
1195     uint numLights = grid.ccLights;                              
1196                                 
1197     for (uint i = 0u; i < 100u; i++) {                              
1198       if (i >= numLights) break;                              
1199       uint lightIndex = getGridLightIndex(grid.offset, i);                              
1200       CCLight light = getCCLight(lightIndex);                              
1201       vec3 SLU = light.cc_lightPos.xyz - position;                              
1202       vec3 SL = normalize(SLU);                              
1203       vec3 SH = normalize(SL + V);                              
1204       float SNL = max(dot(N, SL), 0.001);                              
1205       float SNH = max(dot(N, SH), 0.0);                              
1206                                 
1207       float distSqr = dot(SLU, SLU);                              
1208       float litRadius = light.cc_lightSizeRangeAngle.x;                              
1209       float litRadiusSqr = litRadius * litRadius;                              
1210       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));                              
1211       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);                              
1212       attRadiusSqrInv *= attRadiusSqrInv;                              
1213       float att = GetDistAtt(distSqr, attRadiusSqrInv);                              
1214       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                              
1215                                 
1216       if (light.cc_lightPos.w > 0.0) {                              
1217         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);                              
1218         float cosOuter = light.cc_lightSizeRangeAngle.z;                              
1219         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                              
1220         float litAngleOffset = -cosOuter * litAngleScale;                              
1221         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);                              
1222       }                              
1223                                 
1224       vec3 lightColor = light.cc_lightColor.rgb;                              
1225                                 
1226       float shadow = 1.0;                              
1227       #if CC_RECEIVE_SHADOW                              
1228         if (light.cc_lightPos.w > 0.0) {                              
1229           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                              
1230         }                              
1231       #endif                              
1232                                 
1233       lightColor *= shadow;                              
1234       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);                              
1235     }                              
1236                                 
1237     return vec4(finalColor, 0.0);                              
1238   }                              
1239                                 
1240   #endif                                                           
1241                                                                    
1242                           
1243                                                                    
1244   void main () {                                                   
1245     StandardSurface s; surf(s);                                    
1246     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                     
1247     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);  
1248     #else                                                          
1249     vec4 color = CCStandardShadingAdditive(s, v_shadowPos); 
1250     #endif                                                         
1251     gl_FragData[0] = CCFragOutput(color);                              
1252   }                                                                
1253                                                                    
1254 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING) 
1255                                                                    
1256                           
1257                                                                    
1258   void main () {                                                   
1259     StandardSurface s; surf(s);                                    
1260     vec4 color = CCStandardShadingBase(s, v_shadowPos);     
1261     CC_APPLY_FOG(color, s.position.xyz);                           
1262     gl_FragData[0] = CCFragOutput(color);                              
1263   }                                                                
1264                                                                    
1265 #elif CC_PIPELINE_TYPE == 1                
1266                                     
1267   vec2 signNotZero(vec2 v) {                                  
1268     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);                                  
1269   }                                  
1270   vec2 float32x3_to_oct(in vec3 v) {                                  
1271     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));                                  
1272     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;                                  
1273   }                                  
1274                                     
1275                                     
1276                                     
1277                                     
1278                                                                    
1279                           
1280                           
1281                           
1282                                                                    
1283   void main () {                                                   
1284     StandardSurface s; surf(s);                                    
1285     gl_FragData[0] = s.albedo;                                         
1286     gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic); 
1287     gl_FragData[2] = vec4(s.emissive, s.occlusion);                    
1288   }                                                                
1289                                                                    
1290 #endif                                                             
1291   
2 #define USE_INSTANCING 1  
3 #define USE_BATCHING 1  
4 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
5 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
6 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
7 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
8 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
9 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
10 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
11 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
12 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
13 #define CC_USE_SKINNING 1  
14 #define CC_USE_BAKED_ANIMATION 1  
15 #define USE_LIGHTMAP 1  
16 #define CC_RECEIVE_SHADOW 1  
17 #define CC_USE_MORPH 1  
18 #define CC_MORPH_TARGET_COUNT 2  
19 #define CC_MORPH_PRECOMPUTED 1  
20 #define CC_MORPH_TARGET_HAS_POSITION 1  
21 #define CC_MORPH_TARGET_HAS_NORMAL 1  
22 #define CC_MORPH_TARGET_HAS_TANGENT 1  
23 #define CC_USE_FOG 0  
24 #define CC_USE_ACCURATE_FOG 1  
25 #define USE_VERTEX_COLOR 1  
26 #define HAS_SECOND_UV 1  
27 #define CC_FORWARD_ADD 1  
28 #define USE_NORMAL_MAP 1  
29 #define SAMPLE_FROM_RT 1  
30 #define CC_USE_IBL 0  
31 #define CC_USE_DIFFUSEMAP 0  
32 #define USE_REFLECTION_DENOISE 1  
33 #define CC_USE_HDR 1  
34 #define USE_ALBEDO_MAP 1  
35 #define USE_PBR_MAP 1  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define USE_OCCLUSION_MAP 1  
38 #define USE_EMISSIVE_MAP 1  
39 #define USE_ALPHA_TEST 1  
40 #define USE_ANISOTROPY 1  
41 #define CC_PIPELINE_TYPE 0  
42 #define CC_FORCE_FORWARD_SHADING 1  
43  
44 #ifdef GL_EXT_draw_buffers  
45 #extension GL_EXT_draw_buffers: enable  
46 #endif  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp mat4 cc_matView;  
58   uniform highp vec4 cc_cameraPos;  
59   uniform mediump vec4 cc_mainLitDir;  
60   uniform mediump vec4 cc_mainLitColor;  
61   uniform mediump vec4 cc_ambientSky;  
62   uniform mediump vec4 cc_ambientGround;  
63   uniform mediump vec4 cc_fogColor;  
64   uniform mediump vec4 cc_fogBase;  
65   uniform mediump vec4 cc_fogAdd;  
66   uniform mediump vec4 cc_nearFar;  
67   uniform mediump vec4 cc_viewPort;  
68  
69  
70  
71      uniform vec4 albedo;  
72      uniform vec4 albedoScaleAndCutoff;  
73      uniform vec4 pbrParams;  
74      uniform vec4 miscParams;  
75      uniform vec4 emissive;  
76      uniform vec4 emissiveScaleParam;  
77      uniform vec4 anisoTile;  
78      uniform vec4 hairBaseColor;  
79      uniform vec4 hairSpecColor01;  
80      uniform vec4 hairSpecColor02;  
81      uniform vec2 anisoJitter;  
82      uniform float anisoAOStrength;  
83      uniform float hairSpecMOffset;  
84      uniform float hairSpecAOffset;  
85      uniform float hairSpecMAmt;  
86      uniform float hairSpecAAmt;  
87      uniform float hairSpecIntensity;  
88  
89 float LinearFog(vec4 pos) {  
90   vec4 wPos = pos;  
91   float cam_dis = distance(cc_cameraPos, wPos);  
92   float fogStart = cc_fogBase.x;  
93   float fogEnd = cc_fogBase.y;  
94   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);  
95 }  
96  
97 float ExpFog(vec4 pos) {  
98   vec4 wPos = pos;  
99   float fogAtten = cc_fogAdd.z;  
100   float fogStart = cc_fogBase.x;  
101   float fogDensity = cc_fogBase.z;  
102   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;  
103   float f = exp(-cam_dis * fogDensity);  
104   return f;  
105 }  
106  
107 float ExpSquaredFog(vec4 pos) {  
108   vec4 wPos = pos;  
109   float fogAtten = cc_fogAdd.z;  
110   float fogStart = cc_fogBase.x;  
111   float fogDensity = cc_fogBase.z;  
112   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;  
113   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);  
114   return f;  
115 }  
116  
117 float LayeredFog(vec4 pos) {  
118   vec4 wPos = pos;  
119   float fogAtten = cc_fogAdd.z;  
120   float _FogTop = cc_fogAdd.x;  
121   float _FogRange = cc_fogAdd.y;  
122   vec3 camWorldProj = cc_cameraPos.xyz;  
123   camWorldProj.y = 0.;  
124   vec3 worldPosProj = wPos.xyz;  
125   worldPosProj.y = 0.;  
126   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;  
127   float fDeltaY, fDensityIntegral;  
128   if (cc_cameraPos.y > _FogTop) {  
129     if (wPos.y < _FogTop) {  
130       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;  
131       fDensityIntegral = fDeltaY * fDeltaY * 0.5;  
132     } else {  
133       fDeltaY = 0.;  
134       fDensityIntegral = 0.;  
135     }  
136   } else {  
137     if (wPos.y < _FogTop) {  
138       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;  
139       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;  
140       fDeltaY = abs(fDeltaA - fDeltaB);  
141       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));  
142     } else {  
143       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;  
144       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);  
145     }  
146   }  
147   float fDensity;  
148   if (fDeltaY != 0.) {  
149     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;  
150   } else {  
151     fDensity = 0.;  
152   }  
153   float f = exp(-fDensity);  
154   return f;  
155 }  
156  
157 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)  
158 {  
159   #if CC_USE_FOG == 0  
160 	factor = LinearFog(pos);  
161   #elif CC_USE_FOG == 1  
162     factor = ExpFog(pos);  
163   #elif CC_USE_FOG == 2  
164     factor = ExpSquaredFog(pos);  
165   #elif CC_USE_FOG == 3  
166     factor = LayeredFog(pos);  
167   #else  
168     factor = 1.0;  
169   #endif  
170 }  
171  
172 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {  
173   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);  
174 }  
175  
176  
177 #if !CC_USE_ACCURATE_FOG  
178 varying float v_fog_factor;  
179 #endif  
180  
181 void CC_APPLY_FOG(inout vec4 color) {  
182 #if !CC_USE_ACCURATE_FOG  
183     CC_APPLY_FOG_BASE(color, v_fog_factor);  
184 #endif  
185 }  
186  
187 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {  
188 #if CC_USE_ACCURATE_FOG  
189     float factor;  
190     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);  
191 #else  
192     float factor = v_fog_factor;  
193 #endif  
194     CC_APPLY_FOG_BASE(color, factor);  
195 }  
196  
197 vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
198  
199     #ifdef GL_EXT_shader_texture_lod  
200       return texture2DLodEXT(tex, coord, lod);  
201     #else  
202       return texture2D(tex, coord, lod);  
203     #endif  
204  
205 }  
206  
207 vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
208  
209     #ifdef GL_EXT_shader_texture_lod  
210       return textureCubeLodEXT(tex, coord, lod);  
211     #else  
212       return textureCube(tex, coord, lod);  
213     #endif  
214  
215 }  
216  
217  
218  
219  
220  
221  
222  
223  
224  
225  
226  
227 #define QUATER_PI         0.78539816340  
228 #define HALF_PI           1.57079632679  
229 #define PI                3.14159265359  
230 #define PI2               6.28318530718  
231 #define PI4               12.5663706144  
232  
233 #define INV_QUATER_PI     1.27323954474  
234 #define INV_HALF_PI       0.63661977237  
235 #define INV_PI            0.31830988618  
236 #define INV_PI2           0.15915494309  
237 #define INV_PI4           0.07957747155  
238  
239 #define EPSILON           1e-6  
240 #define EPSILON_LOWP      1e-4  
241 #define LOG2              1.442695  
242 #define EXP_VALUE         2.71828183f  
243 #define FP_MAX            65504.0  
244 #define FP_SCALE          0.0009765625  
245 #define FP_SCALE_INV      1024.0  
246 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
247  
248  
249  
250  
251  
252  
253  
254 vec3 SRGBToLinear (vec3 gamma) {  
255   return gamma * gamma;  
256 }  
257 uniform highp mat4 cc_matLightView;  
258   uniform highp vec4 cc_shadowInvProjDepthInfo;  
259   uniform highp vec4 cc_shadowProjDepthInfo;  
260   uniform highp vec4 cc_shadowProjInfo;  
261   uniform mediump vec4 cc_shadowNFLSInfo;  
262   uniform mediump vec4 cc_shadowWHPBInfo;  
263   uniform mediump vec4 cc_shadowLPNNInfo;  
264  
265  
266  
267  
268  
269  
270  
271  
272 highp float unpackHighpData (float mainPart, float modPart) {  
273   highp float data = mainPart;  
274   return data + modPart;  
275 }  
276  
277 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
278   highp float data = mainPart * modValue;  
279   return data + modPart * modValue;  
280 }  
281  
282  
283 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
284   highp vec2 data = mainPart;  
285   return data + modPart;  
286 }  
287  
288 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
289   highp vec2 data = mainPart * modValue;  
290   return data + modPart * modValue;  
291 }  
292  
293  
294 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
295   highp vec3 data = mainPart;  
296   return data + modPart;  
297 }  
298  
299 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
300   highp vec3 data = mainPart * modValue;  
301   return data + modPart * modValue;  
302 }  
303  
304  
305 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
306   highp vec4 data = mainPart;  
307   return data + modPart;  
308 }  
309  
310 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
311   highp vec4 data = mainPart * modValue;  
312   return data + modPart * modValue;  
313 }  
314 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {  
315   float dist = length(viewPos);  
316   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);  
317 }  
318  
319 float CCGetLinearDepth(vec3 worldPos) {  
320   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);  
321   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);  
322 }  
323  
324  
325  
326 #if CC_RECEIVE_SHADOW  
327   uniform highp sampler2D cc_shadowMap;  
328   uniform highp sampler2D cc_spotLightingMap;  
329  
330   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
331   {  
332     vec4 newShadowPos = shadowPos;  
333     if(normalBias > EPSILON_LOWP)  
334     {  
335       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
336       if(viewNormal.z < 0.1)  
337         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
338     }  
339     return newShadowPos;  
340   }  
341  
342   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)  
343   {  
344     vec3 viewSpacePos;  
345     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;  
346     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;  
347     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;  
348     vec4 clipSpacePos;  
349     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;  
350     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);  
351     if (cc_shadowNFLSInfo.z > EPSILON) {  
352       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);  
353       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;  
354     }  
355  
356     return clipSpacePos;  
357   }  
358  
359   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
360   {  
361     float coeffA = cc_shadowProjDepthInfo.x;  
362     float coeffB = cc_shadowProjDepthInfo.y;  
363     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
364     viewSpacePos_z += viewspaceDepthBias;  
365     vec4 result = shadowPos;  
366     result.z = viewSpacePos_z * coeffA + coeffB;  
367     return result;  
368   }  
369  
370   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
371     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
372     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
373     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
374         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
375         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
376     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
377  
378     float shadow = 0.0;  
379     float closestDepth = 0.0;  
380     if (cc_shadowLPNNInfo.y > EPSILON) {  
381       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
382     } else {  
383       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
384     }  
385     shadow = step(clipPos.z, closestDepth);  
386  
387     return shadow;  
388   }  
389  
390   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
391     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
392     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
393     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
394         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
395         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
396     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
397  
398     float offsetDepth = clipPos.z;  
399     vec2 mapSize = cc_shadowWHPBInfo.xy;  
400     vec2 oneTap = 1.0 / mapSize;  
401     vec2 clipPos_offset = clipPos.xy + oneTap;  
402  
403     float block0, block1, block2, block3;  
404     if (cc_shadowLPNNInfo.y > EPSILON) {  
405       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
406       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
407       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
408       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
409     } else {  
410       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
411       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
412       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
413       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
414     }  
415  
416     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
417     float resultX = mix(block0, block1, coefX);  
418     float resultY = mix(block2, block3, coefX);  
419     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
420  
421     return mix(resultX, resultY, coefY);  
422   }  
423  
424   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
425     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
426     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
427     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
428         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
429         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
430     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
431  
432     float offsetDepth = clipPos.z;  
433     vec2 mapSize = cc_shadowWHPBInfo.xy;  
434     vec2 oneTap = 1.0 / mapSize;  
435     float clipPos_offset_L = clipPos.x - oneTap.x;  
436     float clipPos_offset_R = clipPos.x + oneTap.x;  
437     float clipPos_offset_U = clipPos.y - oneTap.y;  
438     float clipPos_offset_D = clipPos.y + oneTap.y;  
439  
440     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
441     if (cc_shadowLPNNInfo.y > EPSILON) {  
442       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
443       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
444       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
445       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
446       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
447       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
448       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
449       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
450       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
451     } else {  
452       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
453       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
454       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
455       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
456       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
457       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
458       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
459       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
460       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
461     }  
462  
463     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
464     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
465  
466     float shadow = 0.0;  
467     float resultX = mix(block0, block1, coefX);  
468     float resultY = mix(block3, block4, coefX);  
469     shadow += mix(resultX , resultY, coefY);  
470  
471     resultX = mix(block1, block2, coefX);  
472     resultY = mix(block4, block5, coefX);  
473     shadow += mix(resultX , resultY, coefY);  
474  
475     resultX = mix(block3, block4, coefX);  
476     resultY = mix(block6, block7, coefX);  
477     shadow += mix(resultX, resultY, coefY);  
478  
479     resultX = mix(block4, block5, coefX);  
480     resultY = mix(block7, block8, coefX);  
481     shadow += mix(resultX, resultY, coefY);  
482  
483     return shadow * 0.25;  
484   }  
485  
486   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {  
487     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);  
488     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
489     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
490         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
491         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
492     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
493  
494     float shadow = 0.0;  
495     float closestDepth = 0.0;  
496     float depth = clipPos.z;  
497  
498     if (cc_shadowLPNNInfo.y > EPSILON) {  
499       closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
500     } else {  
501       closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;  
502     }  
503     shadow = step(depth, closestDepth);  
504  
505     return shadow;  
506   }  
507  
508   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {  
509     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);  
510     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
511     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
512         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
513         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
514     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
515  
516     float depth = 0.0;  
517     if (cc_shadowNFLSInfo.z > EPSILON) {  
518       depth = CCGetLinearDepth(worldPos);  
519     } else {  
520       depth = clipPos.z;  
521     }  
522  
523     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;  
524     vec2 clipPos_offset = clipPos.xy + oneTap;  
525  
526     float block0, block1, block2, block3;  
527     if (cc_shadowLPNNInfo.y > EPSILON) {  
528       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
529       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
530       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
531       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
532     } else {  
533       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);  
534       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);  
535       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);  
536       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
537     }  
538  
539     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;  
540     float resultX = mix(block0, block1, coefX);  
541     float resultY = mix(block2, block3, coefX);  
542     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;  
543  
544     return mix(resultX, resultY, coefY);  
545   }  
546  
547   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {  
548     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);  
549     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
550     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
551         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
552         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
553     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
554  
555     float depth = 0.0;  
556     if (cc_shadowNFLSInfo.z > EPSILON) {  
557       depth = CCGetLinearDepth(worldPos);  
558     } else {  
559       depth = clipPos.z;  
560     }  
561  
562     vec2 mapSize = cc_shadowWHPBInfo.xy;  
563     vec2 oneTap = 1.0 / mapSize;  
564     float clipPos_offset_L = clipPos.x - oneTap.x;  
565     float clipPos_offset_R = clipPos.x + oneTap.x;  
566     float clipPos_offset_U = clipPos.y - oneTap.y;  
567     float clipPos_offset_D = clipPos.y + oneTap.y;  
568  
569     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
570     if (cc_shadowLPNNInfo.y > EPSILON) {  
571       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
572       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
573       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
574       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
575       block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
576       block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
577       block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
578       block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
579       block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
580     } else {  
581       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
582       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);  
583       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
584       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);  
585       block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);  
586       block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);  
587       block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
588       block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);  
589       block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
590     }  
591  
592     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
593     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
594  
595     float shadow = 0.0;  
596     float resultX = mix(block0, block1, coefX);  
597     float resultY = mix(block3, block4, coefX);  
598     shadow += mix(resultX , resultY, coefY);  
599  
600     resultX = mix(block1, block2, coefX);  
601     resultY = mix(block4, block5, coefX);  
602     shadow += mix(resultX , resultY, coefY);  
603  
604     resultX = mix(block3, block4, coefX);  
605     resultY = mix(block6, block7, coefX);  
606     shadow += mix(resultX, resultY, coefY);  
607  
608     resultX = mix(block4, block5, coefX);  
609     resultY = mix(block7, block8, coefX);  
610     shadow += mix(resultX, resultY, coefY);  
611  
612     return shadow * 0.25;  
613   }  
614  
615 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)  
616 {  
617   float pcf = cc_shadowWHPBInfo.z;  
618   if (pcf > 1.9) {  
619     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);  
620   }else if (pcf > 0.9) {  
621     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);  
622   }else {  
623     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);  
624   }  
625 }  
626  
627 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
628 {  
629   float realtimeShadow = 1.0;  
630   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
631  
632   float pcf = cc_shadowWHPBInfo.z;  
633   if (pcf > 1.9) {  
634     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
635   }else if (pcf > 0.9) {  
636     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
637   }else {  
638     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
639   }  
640   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
641 }  
642 #endif  
643  
644  
645  
646 #if CC_USE_IBL  
647   uniform samplerCube cc_environment;  
648  
649  
650  
651  
652   vec3 unpackRGBE (vec4 rgbe) {  
653     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
654   }  
655  
656  
657   #if CC_USE_DIFFUSEMAP  
658     uniform samplerCube cc_diffuseMap;  
659   #endif  
660 #endif  
661  
662 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
663   vec3 NxH = cross(N, H);  
664   float OneMinusNoHSqr = dot(NxH, NxH);  
665   float a = roughness * roughness;  
666   float n = NoH * a;  
667   float p = a / (OneMinusNoHSqr + n * n);  
668   return p * p;  
669 }  
670  
671 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
672   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
673 }  
674  
675 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
676   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
677   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
678   vec4 r = roughness * c0 + c1;  
679   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
680   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
681   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
682   return specular * AB.x + AB.y;  
683 }  
684  
685 #if USE_REFLECTION_DENOISE  
686   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
687     #if CC_USE_IBL  
688     	float mip = roughness * mipCount;  
689     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
690     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
691  
692     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
693      	vec4 filtered = textureCube(cc_environment, R);  
694  
695       #if CC_USE_IBL == 2  
696       	biased.rgb = unpackRGBE(biased);  
697       	filtered.rgb = unpackRGBE(filtered);  
698       #else  
699       	biased.rgb = SRGBToLinear(biased.rgb);  
700       	filtered.rgb = SRGBToLinear(filtered.rgb);  
701       #endif  
702  
703       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
704     #else  
705       return vec3(0.0, 0.0, 0.0);  
706     #endif  
707   }  
708 #endif  
709  
710  
711 struct StandardSurface {  
712   vec4 albedo;  
713  
714   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
715   vec3 position, position_fract_part;  
716   #else  
717   vec3 position;  
718   #endif  
719   vec3 normal;  
720   vec3 emissive;  
721   vec3 lightmap;  
722   float lightmap_test;  
723   float roughness;  
724   float metallic;  
725   float occlusion;  
726   float specularIntensity;  
727  
728   #if CC_RECEIVE_SHADOW  
729     vec2 shadowBias;  
730   #endif  
731 };  
732  
733 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
734   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
735  
736   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
737  
738   vec3 position;  
739  
740   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
741   position = unpackHighpData(s.position, s.position_fract_part);  
742   #else  
743   position = s.position;  
744   #endif  
745  
746   vec3 N = normalize(s.normal);  
747   vec3 V = normalize(cc_cameraPos.xyz - position);  
748  
749   float NV = max(abs(dot(N, V)), 0.0);  
750   specular = BRDFApprox(specular, s.roughness, NV);  
751  
752   vec3 L = normalize(-cc_mainLitDir.xyz);  
753   vec3 H = normalize(L + V);  
754   float NH = max(dot(N, H), 0.0);  
755   float NL = max(dot(N, L), 0.0);  
756   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
757   vec3 diffuseContrib = diffuse / PI;  
758   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
759   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
760  
761   float shadow = 1.0;  
762   #if CC_RECEIVE_SHADOW  
763     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
764       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
765     }  
766   #endif  
767  
768   dirlightContrib *= shadow;  
769   finalColor *= dirlightContrib;  
770  
771   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
772     if (s.lightmap_test > EPSILON_LOWP) {  
773       finalColor = diffuse * s.lightmap.rgb * shadow;  
774     }  
775   #endif  
776  
777   float fAmb = 0.5 - N.y * 0.5;  
778   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
779  
780  
781   #if CC_USE_IBL  
782     #if CC_USE_DIFFUSEMAP  
783       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
784       #if CC_USE_DIFFUSEMAP == 2  
785         ambDiff = unpackRGBE(diffuseMap);  
786       #else  
787         ambDiff = SRGBToLinear(diffuseMap.rgb);  
788       #endif  
789     #endif  
790  
791     vec3 R = normalize(reflect(-V, N));  
792  
793     #if USE_REFLECTION_DENOISE  
794       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
795     #else  
796       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
797  
798       #if CC_USE_IBL == 2  
799         vec3 env = unpackRGBE(envmap);  
800       #else  
801         vec3 env = SRGBToLinear(envmap.rgb);  
802       #endif  
803     #endif  
804  
805     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
806   #endif  
807  
808   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
809  
810  
811   finalColor += s.emissive;  
812  
813   return vec4(finalColor, s.albedo.a);  
814 }  
815  
816  
817  
818 vec3 ACESToneMap (vec3 color) {  
819   color = min(color, vec3(8.0));  
820   const float A = 2.51;  
821   const float B = 0.03;  
822   const float C = 2.43;  
823   const float D = 0.59;  
824   const float E = 0.14;  
825   return (color * (A * color + B)) / (color * (C * color + D) + E);  
826 }  
827  
828  
829  
830 vec4 CCFragOutput (vec4 color) {  
831   #if CC_USE_HDR  
832     color.rgb = ACESToneMap(color.rgb);  
833   #endif  
834   color.rgb = sqrt(color.rgb);  
835   return color;  
836 }  
837  
838  
839  
840  
841 varying highp vec4 v_shadowPos;  
842  
843  
844  
845 #if CC_RECEIVE_SHADOW  
846  
847  
848  
849 #endif  
850  
851  
852  
853  
854 #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
855   varying vec3 v_luv;  
856   uniform sampler2D cc_lightingMap;  
857  
858 #endif  
859  
860 void alphaTestFunc(float alpha)  
861 {  
862   if (alpha < albedoScaleAndCutoff.w) discard;  
863 }  
864  
865  
866 varying vec3 v_position;  
867 varying vec2 v_uv;  
868 varying vec2 v_uv1;  
869 varying vec3 v_normal;  
870 varying vec3 v_tangent;  
871 varying vec3 v_bitangent;  
872  
873 varying vec4 worldViewDir;  
874 varying vec4 worldHalfDir;  
875  
876 #if USE_VERTEX_COLOR  
877   varying vec4 v_color;  
878 #endif  
879  
880 #if USE_ALBEDO_MAP  
881   uniform sampler2D albedoMap;  
882   #endif  
883 #if USE_NORMAL_MAP  
884   uniform sampler2D normalMap;  
885   #endif  
886 #if USE_PBR_MAP  
887   uniform sampler2D pbrMap;  
888 #endif  
889 #if USE_METALLIC_ROUGHNESS_MAP  
890   uniform sampler2D metallicRoughnessMap;  
891 #endif  
892 #if USE_OCCLUSION_MAP  
893   uniform sampler2D occlusionMap;  
894 #endif  
895 #if USE_EMISSIVE_MAP  
896   uniform sampler2D emissiveMap;  
897   #endif  
898  
899 #define OCCLUSION_CHANNEL r  
900 #define ROUGHNESS_CHANNEL g  
901 #define METALLIC_CHANNEL  b  
902 #define SPECULARINTENSITY_CHANNEL w  
903  
904  
905 #if USE_ALPHA_TEST  
906   #endif  
907  
908 #if USE_ANISOTROPY  
909   uniform sampler2D anisoRamp;  
910 #endif  
911  
912 float anisotropyIndex( float offset, float factor, float amt ) {  
913   vec3 jitterN = v_bitangent + (v_normal * offset + factor);  
914   float NHdot = dot(normalize(jitterN), normalize(worldHalfDir.xyz));  
915   float sinNH = max(0.01, sqrt(1.0 - pow(NHdot, 2.0)));  
916   float atten = smoothstep(-1.0, 0.0, NHdot);  
917   return pow(sinNH, amt) * atten;  
918 }  
919  
920 void surf (out StandardSurface s) {  
921   vec4 baseColor = albedo;  
922  
923   #if USE_VERTEX_COLOR  
924     baseColor.rgb *= SRGBToLinear(v_color.rgb);  
925     baseColor.a *= v_color.a;  
926   #endif  
927  
928   #if USE_ALBEDO_MAP  
929     vec4 texColor = texture2D(albedoMap, options([v_uv, v_uv1]));  
930     texColor.rgb = SRGBToLinear(texColor.rgb);  
931     baseColor *= texColor;  
932   #endif  
933  
934   s.albedo = baseColor;  
935   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
936  
937   #if USE_ALPHA_TEST  
938     alphaTestFunc(s.albedo.options([a, r]));  
939   #endif  
940  
941   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
942     vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);  
943     s.lightmap = UnpackLightingmap(lightColor);  
944     s.lightmap_test = v_luv.z;  
945   #endif  
946  
947   s.normal = v_normal;  
948   #if USE_NORMAL_MAP  
949     vec3 nmmp = texture2D(normalMap, options([v_uv, v_uv1])).xyz - vec3(0.5);  
950     s.normal =  
951       (nmmp.x * miscParams.x) * normalize(v_tangent) +  
952       (nmmp.y * miscParams.x) * normalize(v_bitangent) +  
953       nmmp.z * normalize(s.normal);  
954   #endif  
955  
956   s.position = v_position;  
957  
958   vec4 pbr = pbrParams;  
959   #if USE_PBR_MAP  
960     vec4 res = texture2D(pbrMap, options([v_uv, v_uv1]));  
961     pbr.x *= res.OCCLUSION_CHANNEL;  
962     pbr.y *= res.ROUGHNESS_CHANNEL;  
963     pbr.z *= res.METALLIC_CHANNEL;  
964     pbr.w *= res.SPECULARINTENSITY_CHANNEL;  
965   #endif  
966  
967   #if USE_METALLIC_ROUGHNESS_MAP  
968     vec4 metallicRoughness = texture2D(metallicRoughnessMap, options([v_uv, v_uv1]));  
969     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
970     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
971   #endif  
972  
973   #if USE_OCCLUSION_MAP  
974     pbr.x *= texture2D(occlusionMap, options([v_uv, v_uv1])).OCCLUSION_CHANNEL;  
975   #endif  
976   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
977   s.roughness = clamp(pbr.y, 0.04, 1.0);  
978   s.metallic = pbr.z;  
979  
980   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
981   #if USE_EMISSIVE_MAP  
982     s.emissive *= SRGBToLinear(texture2D(emissiveMap, options([v_uv, v_uv1])).rgb);  
983   #endif  
984  
985   #if USE_ANISOTROPY  
986     vec2 anisoUV = v_uv * anisoTile.xy + anisoTile.zw;  
987     vec4 anisoMap = texture2D(anisoRamp, anisoUV);  
988     float jitterFactor = anisoMap.r * anisoJitter.x + anisoMap.g * anisoJitter.y;  
989     float aoFactor = mix(1.0, 0.0, anisoAOStrength * pbr.x);  
990  
991     vec4 hairSpec = clamp((anisotropyIndex(hairSpecMOffset, jitterFactor, hairSpecMAmt) * hairSpecColor01 * hairSpecIntensity + anisotropyIndex(hairSpecAOffset, jitterFactor, hairSpecAAmt) * hairSpecColor02 * hairSpecIntensity) *  
992                           aoFactor *  
993                           pow((1.0 - dot(v_normal, worldViewDir.xyz)), 2.25),  
994                           0.0, 1.51);  
995  
996     s.albedo.rgb += hairBaseColor.rgb + hairSpec.rgb;  
997   #endif  
998 }  
999  
1000  
1001 #if CC_FORWARD_ADD  
1002  
1003  
1004  
1005   #if CC_PIPELINE_TYPE == 0  
1006     #define LIGHTS_PER_PASS 1  
1007   #else  
1008     #define LIGHTS_PER_PASS 10  
1009   #endif  
1010  
1011   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0  
1012   uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];  
1013   uniform vec4 cc_lightColor[LIGHTS_PER_PASS];  
1014   uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];  
1015   uniform vec4 cc_lightDir[LIGHTS_PER_PASS];  
1016  
1017   #endif  
1018  
1019  
1020  
1021  
1022   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {  
1023     float factor = distSqr * invSqrAttRadius;  
1024     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);  
1025     return smoothFactor * smoothFactor;  
1026   }  
1027  
1028   float GetDistAtt (float distSqr, float invSqrAttRadius) {  
1029     float attenuation = 1.0 / max(distSqr, 0.01*0.01);  
1030     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);  
1031     return attenuation;  
1032   }  
1033  
1034   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {  
1035     float cd = dot(litDir, L);  
1036     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);  
1037     return (attenuation * attenuation);  
1038   }  
1039  
1040  
1041   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0  
1042   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {  
1043     vec3 position;  
1044  
1045     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
1046     position = unpackHighpData(s.position, s.position_fract_part);  
1047     #else  
1048     position = s.position;  
1049     #endif  
1050     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
1051     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);  
1052     vec3 diffuseContrib = diffuse / PI;  
1053  
1054     vec3 N = normalize(s.normal);  
1055     vec3 V = normalize(cc_cameraPos.xyz - position);  
1056     float NV = max(abs(dot(N, V)), 0.0);  
1057     specular = BRDFApprox(specular, s.roughness, NV);  
1058     vec3 finalColor = vec3(0.0);  
1059  
1060     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);  
1061  
1062     for (int i = 0; i < LIGHTS_PER_PASS; i++) {  
1063       if (i >= numLights) break;  
1064       vec3 SLU = cc_lightPos[i].xyz - position;  
1065       vec3 SL = normalize(SLU);  
1066       vec3 SH = normalize(SL + V);  
1067       float SNL = max(dot(N, SL), 0.0);  
1068       float SNH = max(dot(N, SH), 0.0);  
1069  
1070       float distSqr = dot(SLU, SLU);  
1071       float litRadius = cc_lightSizeRangeAngle[i].x;  
1072       float litRadiusSqr = litRadius * litRadius;  
1073       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);  
1074       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);  
1075       attRadiusSqrInv *= attRadiusSqrInv;  
1076       float att = GetDistAtt(distSqr, attRadiusSqrInv);  
1077       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);  
1078  
1079       if (cc_lightPos[i].w > 0.0) {  
1080         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);  
1081         float cosOuter = cc_lightSizeRangeAngle[i].z;  
1082         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);  
1083         float litAngleOffset = -cosOuter * litAngleScale;  
1084         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);  
1085       }  
1086  
1087       vec3 lightColor = cc_lightColor[i].rgb;  
1088  
1089       float shadow = 1.0;  
1090       #if CC_RECEIVE_SHADOW  
1091         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {  
1092           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);  
1093         }  
1094       #endif  
1095  
1096       lightColor *= shadow;  
1097       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);  
1098     }  
1099  
1100     return vec4(finalColor, 0.0);  
1101   }  
1102   #endif  
1103  
1104   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1  
1105   readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };  
1106   readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };  
1107   readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };  
1108  
1109   struct CCLight  
1110   {  
1111     vec4 cc_lightPos;  
1112     vec4 cc_lightColor;  
1113     vec4 cc_lightSizeRangeAngle;  
1114     vec4 cc_lightDir;  
1115   };  
1116  
1117   struct Cluster  
1118   {  
1119     vec3 minBounds;  
1120     vec3 maxBounds;  
1121   };  
1122  
1123   struct LightGrid  
1124   {  
1125     uint offset;  
1126     uint ccLights;  
1127   };  
1128  
1129  
1130  
1131   CCLight getCCLight(uint i)  
1132   {  
1133     CCLight light;  
1134     light.cc_lightPos = b_ccLights[4u * i + 0u];  
1135     light.cc_lightColor = b_ccLights[4u * i + 1u];  
1136     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];  
1137     light.cc_lightDir = b_ccLights[4u * i + 3u];  
1138     return light;  
1139   }  
1140  
1141   LightGrid getLightGrid(uint cluster)  
1142   {  
1143     uvec4 gridvec = b_clusterLightGrid[cluster];  
1144     LightGrid grid;  
1145     grid.offset = gridvec.x;  
1146     grid.ccLights = gridvec.y;  
1147     return grid;  
1148   }  
1149  
1150   uint getGridLightIndex(uint start, uint offset)  
1151   {  
1152     return b_clusterLightIndices[start + offset];  
1153   }  
1154  
1155   uint getClusterZIndex(vec4 worldPos)  
1156   {  
1157     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);  
1158     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));  
1159     float eyeDepth = -(cc_matView * worldPos).z;  
1160     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));  
1161     return zIndex;  
1162   }  
1163  
1164   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)  
1165   {  
1166     uint zIndex = getClusterZIndex(worldPos);  
1167     float clusterSizeX = ceil(cc_viewPort.z / float(16));  
1168     float clusterSizeY = ceil(cc_viewPort.w / float(8));  
1169     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);  
1170     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;  
1171     return cluster;  
1172   }  
1173  
1174   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {  
1175     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
1176     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);  
1177     vec3 diffuseContrib = diffuse / PI;  
1178  
1179     vec3 position;  
1180  
1181     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
1182     position = unpackHighpData(s.position, s.position_fract_part);  
1183     #else  
1184     position = s.position;  
1185     #endif  
1186  
1187     vec3 N = normalize(s.normal);  
1188     vec3 V = normalize(cc_cameraPos.xyz - position);  
1189     float NV = max(abs(dot(N, V)), 0.001);  
1190     specular = BRDFApprox(specular, s.roughness, NV);  
1191     vec3 finalColor = vec3(0.0);  
1192  
1193     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));  
1194     LightGrid grid = getLightGrid(cluster);  
1195     uint numLights = grid.ccLights;  
1196  
1197     for (uint i = 0u; i < 100u; i++) {  
1198       if (i >= numLights) break;  
1199       uint lightIndex = getGridLightIndex(grid.offset, i);  
1200       CCLight light = getCCLight(lightIndex);  
1201       vec3 SLU = light.cc_lightPos.xyz - position;  
1202       vec3 SL = normalize(SLU);  
1203       vec3 SH = normalize(SL + V);  
1204       float SNL = max(dot(N, SL), 0.001);  
1205       float SNH = max(dot(N, SH), 0.0);  
1206  
1207       float distSqr = dot(SLU, SLU);  
1208       float litRadius = light.cc_lightSizeRangeAngle.x;  
1209       float litRadiusSqr = litRadius * litRadius;  
1210       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));  
1211       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);  
1212       attRadiusSqrInv *= attRadiusSqrInv;  
1213       float att = GetDistAtt(distSqr, attRadiusSqrInv);  
1214       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);  
1215  
1216       if (light.cc_lightPos.w > 0.0) {  
1217         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);  
1218         float cosOuter = light.cc_lightSizeRangeAngle.z;  
1219         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);  
1220         float litAngleOffset = -cosOuter * litAngleScale;  
1221         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);  
1222       }  
1223  
1224       vec3 lightColor = light.cc_lightColor.rgb;  
1225  
1226       float shadow = 1.0;  
1227       #if CC_RECEIVE_SHADOW  
1228         if (light.cc_lightPos.w > 0.0) {  
1229           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);  
1230         }  
1231       #endif  
1232  
1233       lightColor *= shadow;  
1234       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);  
1235     }  
1236  
1237     return vec4(finalColor, 0.0);  
1238   }  
1239  
1240   #endif  
1241  
1242  
1243  
1244   void main () {  
1245     StandardSurface s; surf(s);  
1246     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1  
1247     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);  
1248     #else  
1249     vec4 color = CCStandardShadingAdditive(s, v_shadowPos);  
1250     #endif  
1251     gl_FragData[0] = CCFragOutput(color);  
1252   }  
1253  
1254 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)  
1255  
1256  
1257  
1258   void main () {  
1259     StandardSurface s; surf(s);  
1260     vec4 color = CCStandardShadingBase(s, v_shadowPos);  
1261     CC_APPLY_FOG(color, s.position.xyz);  
1262     gl_FragData[0] = CCFragOutput(color);  
1263   }  
1264  
1265 #elif CC_PIPELINE_TYPE == 1  
1266  
1267   vec2 signNotZero(vec2 v) {  
1268     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);  
1269   }  
1270   vec2 float32x3_to_oct(in vec3 v) {  
1271     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));  
1272     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;  
1273   }  
1274  
1275  
1276  
1277  
1278  
1279  
1280  
1281  
1282  
1283   void main () {  
1284     StandardSurface s; surf(s);  
1285     gl_FragData[0] = s.albedo;  
1286     gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);  
1287     gl_FragData[2] = vec4(s.emissive, s.occlusion);  
1288   }  
1289  
1290 #endif  
1291  
at Object.encode (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-worker\node_modules\v-stacks\index.js:14:17)  
at Logger._logHandler (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-worker\static\script.ccc:1:531)  
at Logger.record (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-logger\lib\renderer.ccc:1:458)  
at console.error (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-logger\lib\renderer.ccc:1:1414)  
at EffectImporter.import (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\effect.ccc:1:1894)  
at ImportTask.importAsset (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:2325)  
at async ImportTask.exec (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:596)  
at async ParallelQueue._generate (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\asset-db.ccc:1:2655)
2022-04-26T14:33:59.260Z - error: [Asset DB] J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json: ENOENT: no such file or directory, open 'J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json'Error: J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json: ENOENT: no such file or directory, open 'J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json'
    at Object.openSync (fs.js:476:3)
    at Object.func [as openSync] (electron/js2c/asar_bundle.js:5:1846)
    at Object.readFileSync (fs.js:377:35)
    at Object.e.readFileSync (electron/js2c/asar_bundle.js:5:8872)
    at Object.readFileSync (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\jsonfile\index.js:61:22)
    at Object.upgradeProperties (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\utils\material-upgrader.ccc:1:1795)
    at async MaterialImporter.import (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\material.ccc:1:701)
    at async ImportTask.importAsset (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:2311)
    at async ImportTask.exec (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:596)
    at async ParallelQueue._generate (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\asset-db.ccc:1:2655)
2022-04-26T14:33:59.549Z - warn: [Asset DB] 材质 [face_eyeball] 的 [Transparent color] 属性不允许是贴图。 [{asset(3e4bec32-3bc0-4cb4-b5d2-8a380402eea1)}][Asset DB] 材质 [face_eyeball] 的 [Transparent color] 属性不允许是贴图。 [{asset(3e4bec32-3bc0-4cb4-b5d2-8a380402eea1)}]  
at J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\utils\fbx-converter.ccc:1:3014  
at J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\utils\fbx-converter.ccc:1:3285  
at Object.printLogs (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\utils\fbx-converter.ccc:1:3456)  
at async Object.modelConvertRoutine (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\utils\model-convert-routine.ccc:1:1164)  
at async FbxImporter.getGltfFilePath (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\fbx.ccc:1:906)  
at async createGlTfReader (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\gltf\reader-manager.ccc:1:853)
2022-04-26T14:34:05.154Z - verbose: [Scene] Require engine code (0ms)
2022-04-26T14:34:05.154Z - verbose: [Scene] Startup engine (1ms)
2022-04-26T14:34:05.173Z - log: [Scene] Cocos Creator v3.5.0
2022-04-26T14:34:05.610Z - verbose: [Scene] Open engine (456ms)
2022-04-26T14:34:05.611Z - verbose: [Scene] Configure engine (0ms)
2022-04-26T14:34:05.241Z - info: [Scene] Forward render pipeline initialized.
2022-04-26T14:34:05.657Z - error: [Scene] download failed: import://81/81b5ca25-e46d-4fea-9359-eca2bc2109ac.json?_t=1650983645643, status: 0(error)Error: download failed: import://81/81b5ca25-e46d-4fea-9359-eca2bc2109ac.json?_t=1650983645643, status: 0(error)
    at XMLHttpRequest.<anonymous> (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\bin\.cache\dev\editor\bundled\index.js:88847:18)
2022-04-26T14:34:18.759Z - error: [Window] The "path" argument must be of type string or an instance of Buffer or URL. Received undefinedTypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
    at Object.openSync (fs.js:468:10)
    at Object.func [as openSync] (electron/js2c/asar_bundle.js:5:1846)
    at readFileSync (fs.js:377:35)
    at e.readFileSync (electron/js2c/asar_bundle.js:5:8872)
    at Object.refresh (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:308:39)
    at Object.<anonymous> (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:279:26)
    at HTMLElement.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\creator\dist\ui-kit\renderer\components\panel\index.ccc:1:1685)
    at J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:325:28
    at Array.forEach (<anonymous>)
    at Object.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:323:41)
2022-04-26T14:34:22.289Z - error: [Window] The "path" argument must be of type string or an instance of Buffer or URL. Received undefinedTypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
    at Object.openSync (fs.js:468:10)
    at Object.func [as openSync] (electron/js2c/asar_bundle.js:5:1846)
    at readFileSync (fs.js:377:35)
    at e.readFileSync (electron/js2c/asar_bundle.js:5:8872)
    at Object.refresh (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:308:39)
    at Object.<anonymous> (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:279:26)
    at HTMLElement.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\creator\dist\ui-kit\renderer\components\panel\index.ccc:1:1685)
    at J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:325:28
    at Array.forEach (<anonymous>)
    at Object.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:323:41)
2022-04-26T14:34:23.230Z - error: [Window] The "path" argument must be of type string or an instance of Buffer or URL. Received undefinedTypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
    at Object.openSync (fs.js:468:10)
    at Object.func [as openSync] (electron/js2c/asar_bundle.js:5:1846)
    at readFileSync (fs.js:377:35)
    at e.readFileSync (electron/js2c/asar_bundle.js:5:8872)
    at Object.refresh (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:308:39)
    at Object.<anonymous> (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:279:26)
    at HTMLElement.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\creator\dist\ui-kit\renderer\components\panel\index.ccc:1:1685)
    at J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:325:28
    at Array.forEach (<anonymous>)
    at Object.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:323:41)
2022-04-26T14:34:23.787Z - error: [Window] The "path" argument must be of type string or an instance of Buffer or URL. Received undefinedTypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
    at Object.openSync (fs.js:468:10)
    at Object.func [as openSync] (electron/js2c/asar_bundle.js:5:1846)
    at readFileSync (fs.js:377:35)
    at e.readFileSync (electron/js2c/asar_bundle.js:5:8872)
    at Object.refresh (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:308:39)
    at Object.<anonymous> (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\assets\effect.js:279:26)
    at HTMLElement.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\creator\dist\ui-kit\renderer\components\panel\index.ccc:1:1685)
    at J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:325:28
    at Array.forEach (<anonymous>)
    at Object.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\resources\3d\engine\editor\inspector\contributions\asset.js:323:41)
2022-04-26T14:34:44.081Z - warn: Metrics: no valid info
2022-05-05T03:00:40.193Z - log: [Package] menu@1.0.0 enable
2022-05-05T03:00:40.194Z - log: [Package] profile@1.0.0 enable
2022-05-05T03:00:40.200Z - log: [Package] project@1.0.2 enable
2022-05-05T03:00:40.204Z - log: [Package] messages@1.0.0 enable
2022-05-05T03:00:40.206Z - log: [Package] program@1.0.0 enable
2022-05-05T03:00:40.210Z - log: [Package] tester@1.0.0 enable
2022-05-05T03:00:40.213Z - log: [Package] preferences@1.0.0 enable
2022-05-05T03:00:40.372Z - log: Start Quick Compile
2022-05-05T03:00:46.174Z - log: QuickCompiler:Bundling target 0: 2.247s
2022-05-05T03:00:46.175Z - log: QuickCompiler:Compile target 0: 5.782s
2022-05-05T03:00:50.110Z - log: QuickCompiler:Bundling target 1: 2.207s
2022-05-05T03:00:50.112Z - log: QuickCompiler:Compile target 1: 3.937s
2022-05-05T03:00:50.123Z - log: Quick Compile: 9750ms
2022-05-05T03:00:50.357Z - log: Setup mods mgr.: 219.34ms
2022-05-05T03:00:50.361Z - verbose: [Engine] QuickCompile engine (10114ms)
2022-05-05T03:00:50.364Z - log: [Package] engine@1.0.6 enable
2022-05-05T03:00:51.122Z - log: [Package] programming@1.0.0 enable
2022-05-05T03:00:51.368Z - log: [Package] device@1.0.1 enable
2022-05-05T03:00:51.393Z - log: [Package] ui-kit@1.0.1 enable
2022-05-05T03:00:51.414Z - log: [Package] engine-extends@1.0.0 enable
2022-05-05T03:00:51.465Z - log: [Package] asset-db@1.0.0 enable
2022-05-05T03:00:51.498Z - log: [Package] scene@1.0.0 enable
2022-05-05T03:00:51.603Z - log: [Package] server@1.0.0 enable
2022-05-05T03:00:51.603Z - warn: Server: Port 7456 is occupied
2022-05-05T03:00:51.633Z - log: [Package] utils@1.0.0 enable
2022-05-05T03:00:52.302Z - log: [Package] preview@1.0.1 enable
2022-05-05T03:00:52.330Z - log: [Package] animator@1.0.0 enable
2022-05-05T03:00:53.126Z - log: [Package] builder@1.3.2 enable
2022-05-05T03:00:53.155Z - log: [Package] shortcuts@1.0.1 enable
2022-05-05T03:00:53.183Z - log: [Package] animation-graph@1.0.0 enable
2022-05-05T03:00:53.206Z - log: [Package] runtime-dev-tools@1.0.0 enable
2022-05-05T03:00:53.227Z - log: [Package] channel-upload-tools@1.0.0 enable
2022-05-05T03:00:53.254Z - log: [Package] about@1.0.0 enable
2022-05-05T03:00:53.283Z - log: [Package] assets@1.0.0 enable
2022-05-05T03:00:53.311Z - log: [Package] console@1.0.0 enable
2022-05-05T03:00:53.432Z - log: [Package] extension@3.0.16 enable
2022-05-05T03:00:53.461Z - log: [Package] hierarchy@1.0.0 enable
2022-05-05T03:00:53.491Z - log: [Package] inspector@1.0.0 enable
2022-05-05T03:00:53.521Z - log: [Package] lightmap@1.0.4 enable
2022-05-05T03:00:53.539Z - verbose: [AssetDB] Require engine code (809ms)
2022-05-05T03:00:53.564Z - log: [Package] node-library@1.0.1 enable
2022-05-05T03:00:53.587Z - log: [Package] package-asset@1.0.0 enable
2022-05-05T03:00:53.616Z - log: [Package] process@1.0.0 enable
2022-05-05T03:00:53.645Z - log: [Package] reference-image@1.0.0 enable
2022-05-05T03:00:53.668Z - log: [Package] alipay-mini-game@1.0.0 enable
2022-05-05T03:00:53.691Z - log: [Package] android@1.0.0 enable
2022-05-05T03:00:53.715Z - log: [Package] baidu-mini-game@1.0.0 enable
2022-05-05T03:00:53.737Z - log: [Package] bytedance-mini-game@1.0.1 enable
2022-05-05T03:00:53.760Z - log: [Package] cocos-play@1.0.0 enable
2022-05-05T03:00:53.783Z - log: [Package] huawei-agc@1.0.0 enable
2022-05-05T03:00:53.806Z - log: [Package] huawei-quick-game@1.0.0 enable
2022-05-05T03:00:53.830Z - log: [Package] ios@1.0.0 enable
2022-05-05T03:00:53.852Z - log: [Package] ios-app-clip@1.0.0 enable
2022-05-05T03:00:53.876Z - log: [Package] link-sure@1.0.0 enable
2022-05-05T03:00:53.898Z - log: [Package] linux@1.0.0 enable
2022-05-05T03:00:53.920Z - log: [Package] mac@1.0.0 enable
2022-05-05T03:00:53.990Z - log: [Package] native@1.0.0 enable
2022-05-05T03:00:54.013Z - log: [Package] ohos@1.0.0 enable
2022-05-05T03:00:54.036Z - log: [Package] open-harmonyos@1.0.0 enable
2022-05-05T03:00:54.059Z - log: [Package] oppo-mini-game@1.0.0 enable
2022-05-05T03:00:54.082Z - log: [Package] qtt@1.0.0 enable
2022-05-05T03:00:54.105Z - log: [Package] vivo-mini-game@1.0.0 enable
2022-05-05T03:00:54.138Z - log: [Package] web-desktop@1.0.0 enable
2022-05-05T03:00:54.171Z - log: [Package] web-mobile@1.0.0 enable
2022-05-05T03:00:54.203Z - log: [Package] wechatgame@1.0.1 enable
2022-05-05T03:00:54.226Z - log: [Package] windows@1.0.0 enable
2022-05-05T03:00:54.249Z - log: [Package] xiaomi-quick-game@1.0.0 enable
2022-05-05T03:00:54.426Z - log: [Package] cocos-service@3.0.3 enable
2022-05-05T03:00:54.458Z - log: [Package] importer@1.0.0 enable
2022-05-05T03:00:54.641Z - log: [Im-plugin] Check im-plugin version.
2022-05-05T03:00:54.650Z - log: [Package] im-plugin@3.0.8 enable
2022-05-05T03:00:55.360Z - log: [Im-plugin] No online info of im-plugin.
2022-05-05T03:01:00.714Z - error: [Asset DB] ../test/builtin-standard-anisotropy-001.effect - standard-fs: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:929: '[' : syntax error
 

1 #version 100
2 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
3 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
4 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
5 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
6 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
7 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
8 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
9 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
10 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
11 #define USE_INSTANCING 1
12 #define USE_LIGHTMAP 1
13 #define CC_RECEIVE_SHADOW 1
14 #define USE_BATCHING 1
15 #define CC_USE_MORPH 1
16 #define CC_USE_SKINNING 1
17 #define CC_MORPH_TARGET_COUNT 2
18 #define CC_MORPH_PRECOMPUTED 1
19 #define CC_MORPH_TARGET_HAS_POSITION 1
20 #define CC_MORPH_TARGET_HAS_NORMAL 1
21 #define CC_MORPH_TARGET_HAS_TANGENT 1
22 #define CC_USE_BAKED_ANIMATION 1
23 #define CC_USE_FOG 0
24 #define CC_USE_ACCURATE_FOG 1
25 #define USE_VERTEX_COLOR 1
26 #define HAS_SECOND_UV 1
27 #define CC_FORWARD_ADD 1
28 #define USE_NORMAL_MAP 1
29 #define SAMPLE_FROM_RT 1
30 #define CC_USE_IBL 0
31 #define CC_USE_DIFFUSEMAP 0
32 #define USE_REFLECTION_DENOISE 1
33 #define CC_USE_HDR 1
34 #define USE_ALBEDO_MAP 1
35 #define USE_PBR_MAP 1
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define USE_OCCLUSION_MAP 1
38 #define USE_EMISSIVE_MAP 1
39 #define USE_ALPHA_TEST 1
40 #define USE_ANISOTROPY 1
41 #define CC_PIPELINE_TYPE 0
42 #define CC_FORCE_FORWARD_SHADING 1
43 
44 #ifdef GL_EXT_draw_buffers
45 #extension GL_EXT_draw_buffers: enable
46 #endif
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp mat4 cc_matView;
58   uniform highp vec4 cc_cameraPos;
59   uniform mediump vec4 cc_mainLitDir;
60   uniform mediump vec4 cc_mainLitColor;
61   uniform mediump vec4 cc_ambientSky;
62   uniform mediump vec4 cc_ambientGround;
63   uniform mediump vec4 cc_fogColor;
64   uniform mediump vec4 cc_fogBase;
65   uniform mediump vec4 cc_fogAdd;
66   uniform mediump vec4 cc_nearFar;
67   uniform mediump vec4 cc_viewPort;
68 
69 
70 
71      uniform vec4 albedo;
72      uniform vec4 albedoScaleAndCutoff;
73      uniform vec4 pbrParams;
74      uniform vec4 miscParams;
75      uniform vec4 emissive;
76      uniform vec4 emissiveScaleParam;
77      uniform vec4 anisoTile;
78      uniform vec4 hairBaseColor;
79      uniform vec4 hairSpecColor01;
80      uniform vec4 hairSpecColor02;
81      uniform vec2 anisoJitter;
82      uniform float anisoAOStrength;
83      uniform float hairSpecMOffset;
84      uniform float hairSpecAOffset;
85      uniform float hairSpecMAmt;
86      uniform float hairSpecAAmt;
87      uniform float hairSpecIntensity;
88 
89 float LinearFog(vec4 pos) {
90   vec4 wPos = pos;
91   float cam_dis = distance(cc_cameraPos, wPos);
92   float fogStart = cc_fogBase.x;
93   float fogEnd = cc_fogBase.y;
94   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);
95 }
96 
97 float ExpFog(vec4 pos) {
98   vec4 wPos = pos;
99   float fogAtten = cc_fogAdd.z;
100   float fogStart = cc_fogBase.x;
101   float fogDensity = cc_fogBase.z;
102   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
103   float f = exp(-cam_dis * fogDensity);
104   return f;
105 }
106 
107 float ExpSquaredFog(vec4 pos) {
108   vec4 wPos = pos;
109   float fogAtten = cc_fogAdd.z;
110   float fogStart = cc_fogBase.x;
111   float fogDensity = cc_fogBase.z;
112   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
113   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);
114   return f;
115 }
116 
117 float LayeredFog(vec4 pos) {
118   vec4 wPos = pos;
119   float fogAtten = cc_fogAdd.z;
120   float _FogTop = cc_fogAdd.x;
121   float _FogRange = cc_fogAdd.y;
122   vec3 camWorldProj = cc_cameraPos.xyz;
123   camWorldProj.y = 0.;
124   vec3 worldPosProj = wPos.xyz;
125   worldPosProj.y = 0.;
126   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;
127   float fDeltaY, fDensityIntegral;
128   if (cc_cameraPos.y > _FogTop) {
129     if (wPos.y < _FogTop) {
130       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;
131       fDensityIntegral = fDeltaY * fDeltaY * 0.5;
132     } else {
133       fDeltaY = 0.;
134       fDensityIntegral = 0.;
135     }
136   } else {
137     if (wPos.y < _FogTop) {
138       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;
139       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;
140       fDeltaY = abs(fDeltaA - fDeltaB);
141       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));
142     } else {
143       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;
144       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);
145     }
146   }
147   float fDensity;
148   if (fDeltaY != 0.) {
149     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;
150   } else {
151     fDensity = 0.;
152   }
153   float f = exp(-fDensity);
154   return f;
155 }
156 
157 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)
158 {
159   #if CC_USE_FOG == 0
160 	factor = LinearFog(pos);
161   #elif CC_USE_FOG == 1
162     factor = ExpFog(pos);
163   #elif CC_USE_FOG == 2
164     factor = ExpSquaredFog(pos);
165   #elif CC_USE_FOG == 3
166     factor = LayeredFog(pos);
167   #else
168     factor = 1.0;
169   #endif
170 }
171 
172 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {
173   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);
174 }
175 
176 
177 #if !CC_USE_ACCURATE_FOG
178 varying float v_fog_factor;
179 #endif
180 
181 void CC_APPLY_FOG(inout vec4 color) {
182 #if !CC_USE_ACCURATE_FOG
183     CC_APPLY_FOG_BASE(color, v_fog_factor);
184 #endif
185 }
186 
187 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {
188 #if CC_USE_ACCURATE_FOG
189     float factor;
190     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);
191 #else
192     float factor = v_fog_factor;
193 #endif
194     CC_APPLY_FOG_BASE(color, factor);
195 }
196 
197 vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
198   
199     #ifdef GL_EXT_shader_texture_lod
200       return texture2DLodEXT(tex, coord, lod);
201     #else
202       return texture2D(tex, coord, lod);
203     #endif
204   
205 }
206 
207 vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
208   
209     #ifdef GL_EXT_shader_texture_lod
210       return textureCubeLodEXT(tex, coord, lod);
211     #else
212       return textureCube(tex, coord, lod);
213     #endif
214   
215 }
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 #define QUATER_PI         0.78539816340
228 #define HALF_PI           1.57079632679
229 #define PI                3.14159265359
230 #define PI2               6.28318530718
231 #define PI4               12.5663706144
232      
233 #define INV_QUATER_PI     1.27323954474
234 #define INV_HALF_PI       0.63661977237
235 #define INV_PI            0.31830988618
236 #define INV_PI2           0.15915494309
237 #define INV_PI4           0.07957747155
238      
239 #define EPSILON           1e-6
240 #define EPSILON_LOWP      1e-4
241 #define LOG2              1.442695
242 #define EXP_VALUE         2.71828183f
243 #define FP_MAX            65504.0
244 #define FP_SCALE          0.0009765625
245 #define FP_SCALE_INV      1024.0
246 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
247 
248 
249 
250 
251 
252 
253 
254 vec3 SRGBToLinear (vec3 gamma) {
255   return gamma * gamma;
256 }
257 uniform highp mat4 cc_matLightView;
258   uniform highp vec4 cc_shadowInvProjDepthInfo;
259   uniform highp vec4 cc_shadowProjDepthInfo;
260   uniform highp vec4 cc_shadowProjInfo;
261   uniform mediump vec4 cc_shadowNFLSInfo;
262   uniform mediump vec4 cc_shadowWHPBInfo;
263   uniform mediump vec4 cc_shadowLPNNInfo;
264 
265 
266 
267 
268 
269 
270 
271 
272 highp float unpackHighpData (float mainPart, float modPart) {
273   highp float data = mainPart;
274   return data + modPart;
275 }
276 
277 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
278   highp float data = mainPart * modValue;
279   return data + modPart * modValue;
280 }
281 
282 
283 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
284   highp vec2 data = mainPart;
285   return data + modPart;
286 }
287 
288 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
289   highp vec2 data = mainPart * modValue;
290   return data + modPart * modValue;
291 }
292 
293 
294 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
295   highp vec3 data = mainPart;
296   return data + modPart;
297 }
298 
299 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
300   highp vec3 data = mainPart * modValue;
301   return data + modPart * modValue;
302 }
303 
304 
305 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
306   highp vec4 data = mainPart;
307   return data + modPart;
308 }
309 
310 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
311   highp vec4 data = mainPart * modValue;
312   return data + modPart * modValue;
313 }
314 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {
315   float dist = length(viewPos);
316   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);
317 }
318 
319 float CCGetLinearDepth(vec3 worldPos) {
320   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);
321   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);
322 }
323 
324 
325 
326 #if CC_RECEIVE_SHADOW
327   uniform highp sampler2D cc_shadowMap;
328   uniform highp sampler2D cc_spotLightingMap;
329 
330   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
331   {
332     vec4 newShadowPos = shadowPos;
333     if(normalBias > EPSILON_LOWP)
334     {
335       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
336       if(viewNormal.z < 0.1)
337         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
338     }
339     return newShadowPos;
340   }
341   
342   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)
343   {
344     vec3 viewSpacePos;
345     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;
346     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;
347     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;
348     vec4 clipSpacePos;
349     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;
350     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);
351     if (cc_shadowNFLSInfo.z > EPSILON) {
352       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);
353       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;
354     }
355 
356     return clipSpacePos;
357   }
358 
359   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
360   {
361     float coeffA = cc_shadowProjDepthInfo.x;
362     float coeffB = cc_shadowProjDepthInfo.y;
363     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
364     viewSpacePos_z += viewspaceDepthBias;
365     vec4 result = shadowPos;
366     result.z = viewSpacePos_z * coeffA + coeffB;
367     return result;
368   }
369   
370   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
371     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
372     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
373     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
374         clipPos.y < 0.0 || clipPos.y > 1.0 ||
375         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
376     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
377 
378     float shadow = 0.0;
379     float closestDepth = 0.0;
380     if (cc_shadowLPNNInfo.y > EPSILON) {
381       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
382     } else {
383       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
384     }
385     shadow = step(clipPos.z, closestDepth);
386 
387     return shadow;
388   }
389 
390   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
391     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
392     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
393     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
394         clipPos.y < 0.0 || clipPos.y > 1.0 ||
395         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
396     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
397 
398     float offsetDepth = clipPos.z;
399     vec2 mapSize = cc_shadowWHPBInfo.xy;
400     vec2 oneTap = 1.0 / mapSize;
401     vec2 clipPos_offset = clipPos.xy + oneTap;
402 
403     float block0, block1, block2, block3;
404     if (cc_shadowLPNNInfo.y > EPSILON) {
405       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
406       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
407       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
408       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
409     } else {
410       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
411       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
412       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
413       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
414     }
415 
416     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
417     float resultX = mix(block0, block1, coefX);
418     float resultY = mix(block2, block3, coefX);
419     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
420 
421     return mix(resultX, resultY, coefY);
422   }
423 
424   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
425     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
426     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
427     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
428         clipPos.y < 0.0 || clipPos.y > 1.0 ||
429         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
430     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
431 
432     float offsetDepth = clipPos.z;
433     vec2 mapSize = cc_shadowWHPBInfo.xy;
434     vec2 oneTap = 1.0 / mapSize;
435     float clipPos_offset_L = clipPos.x - oneTap.x;
436     float clipPos_offset_R = clipPos.x + oneTap.x;
437     float clipPos_offset_U = clipPos.y - oneTap.y;
438     float clipPos_offset_D = clipPos.y + oneTap.y;
439 
440     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
441     if (cc_shadowLPNNInfo.y > EPSILON) {
442       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
443       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
444       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
445       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
446       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
447       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
448       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
449       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
450       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
451     } else {
452       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
453       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
454       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
455       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
456       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
457       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
458       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
459       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
460       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
461     }
462 
463     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
464     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
465 
466     float shadow = 0.0;
467     float resultX = mix(block0, block1, coefX);
468     float resultY = mix(block3, block4, coefX);
469     shadow += mix(resultX , resultY, coefY);
470 
471     resultX = mix(block1, block2, coefX);
472     resultY = mix(block4, block5, coefX);
473     shadow += mix(resultX , resultY, coefY);
474 
475     resultX = mix(block3, block4, coefX);
476     resultY = mix(block6, block7, coefX);
477     shadow += mix(resultX, resultY, coefY);
478 
479     resultX = mix(block4, block5, coefX);
480     resultY = mix(block7, block8, coefX);
481     shadow += mix(resultX, resultY, coefY);
482 
483     return shadow * 0.25;
484   }
485 
486   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {
487     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
488     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
489     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
490         clipPos.y < 0.0 || clipPos.y > 1.0 ||
491         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
492     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
493 
494     float shadow = 0.0;
495     float closestDepth = 0.0;
496     float depth = clipPos.z;
497 
498     if (cc_shadowLPNNInfo.y > EPSILON) {
499       closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
500     } else {
501       closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;
502     }
503     shadow = step(depth, closestDepth);
504 
505     return shadow;
506   }
507 
508   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {
509     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
510     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
511     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
512         clipPos.y < 0.0 || clipPos.y > 1.0 ||
513         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
514     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
515 
516     float depth = 0.0;
517     if (cc_shadowNFLSInfo.z > EPSILON) {
518       depth = CCGetLinearDepth(worldPos);
519     } else {
520       depth = clipPos.z;
521     }
522 
523     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;
524     vec2 clipPos_offset = clipPos.xy + oneTap;
525 
526     float block0, block1, block2, block3;
527     if (cc_shadowLPNNInfo.y > EPSILON) {
528       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
529       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
530       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
531       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
532     } else {
533       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
534       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);
535       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);
536       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
537     }
538 
539     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;
540     float resultX = mix(block0, block1, coefX);
541     float resultY = mix(block2, block3, coefX);
542     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;
543 
544     return mix(resultX, resultY, coefY);
545   }
546 
547   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {
548     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
549     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
550     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
551         clipPos.y < 0.0 || clipPos.y > 1.0 ||
552         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
553     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
554 
555     float depth = 0.0;
556     if (cc_shadowNFLSInfo.z > EPSILON) {
557       depth = CCGetLinearDepth(worldPos);
558     } else {
559       depth = clipPos.z;
560     }
561 
562     vec2 mapSize = cc_shadowWHPBInfo.xy;
563     vec2 oneTap = 1.0 / mapSize;
564     float clipPos_offset_L = clipPos.x - oneTap.x;
565     float clipPos_offset_R = clipPos.x + oneTap.x;
566     float clipPos_offset_U = clipPos.y - oneTap.y;
567     float clipPos_offset_D = clipPos.y + oneTap.y;
568 
569     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
570     if (cc_shadowLPNNInfo.y > EPSILON) {
571       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
572       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
573       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
574       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
575       block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
576       block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
577       block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
578       block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
579       block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
580     } else {
581       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
582       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);
583       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
584       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);
585       block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
586       block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);
587       block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
588       block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);
589       block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
590     }
591 
592     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
593     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
594 
595     float shadow = 0.0;
596     float resultX = mix(block0, block1, coefX);
597     float resultY = mix(block3, block4, coefX);
598     shadow += mix(resultX , resultY, coefY);
599 
600     resultX = mix(block1, block2, coefX);
601     resultY = mix(block4, block5, coefX);
602     shadow += mix(resultX , resultY, coefY);
603 
604     resultX = mix(block3, block4, coefX);
605     resultY = mix(block6, block7, coefX);
606     shadow += mix(resultX, resultY, coefY);
607 
608     resultX = mix(block4, block5, coefX);
609     resultY = mix(block7, block8, coefX);
610     shadow += mix(resultX, resultY, coefY);
611 
612     return shadow * 0.25;
613   }
614 
615 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
616 {
617   float pcf = cc_shadowWHPBInfo.z;
618   if (pcf > 1.9) { 
619     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);
620   }else if (pcf > 0.9) { 
621     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);
622   }else { 
623     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x); 
624   }
625 }
626 
627 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
628 {
629   float realtimeShadow = 1.0;
630   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
631   
632   float pcf = cc_shadowWHPBInfo.z;
633   if (pcf > 1.9) { 
634     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
635   }else if (pcf > 0.9) {
636     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
637   }else { 
638     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
639   }
640   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
641 }
642 #endif
643 
644 
645 
646 #if CC_USE_IBL
647   uniform samplerCube cc_environment;
648   
649 
650   
651   
652   vec3 unpackRGBE (vec4 rgbe) {
653     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
654   }
655   
656 
657   #if CC_USE_DIFFUSEMAP
658     uniform samplerCube cc_diffuseMap;
659   #endif
660 #endif
661 
662 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
663   vec3 NxH = cross(N, H);
664   float OneMinusNoHSqr = dot(NxH, NxH);
665   float a = roughness * roughness;
666   float n = NoH * a;
667   float p = a / (OneMinusNoHSqr + n * n);
668   return p * p;
669 }
670 
671 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
672   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
673 }
674 
675 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
676   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
677   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
678   vec4 r = roughness * c0 + c1;
679   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
680   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
681   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
682   return specular * AB.x + AB.y;
683 }
684 
685 #if USE_REFLECTION_DENOISE
686   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
687     #if CC_USE_IBL
688     	float mip = roughness * mipCount;
689     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
690     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
691 
692     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
693      	vec4 filtered = textureCube(cc_environment, R);
694 
695       #if CC_USE_IBL == 2
696       	biased.rgb = unpackRGBE(biased);
697       	filtered.rgb = unpackRGBE(filtered);
698       #else
699       	biased.rgb = SRGBToLinear(biased.rgb);
700       	filtered.rgb = SRGBToLinear(filtered.rgb);
701       #endif
702       	
703       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
704     #else
705       return vec3(0.0, 0.0, 0.0);
706     #endif
707   }
708 #endif
709 
710 
711 struct StandardSurface {
712   vec4 albedo;
713   
714   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
715   vec3 position, position_fract_part;
716   #else
717   vec3 position;
718   #endif
719   vec3 normal;
720   vec3 emissive;
721   vec3 lightmap;
722   float lightmap_test;
723   float roughness;
724   float metallic;
725   float occlusion;
726   float specularIntensity;
727 
728   #if CC_RECEIVE_SHADOW
729     vec2 shadowBias;
730   #endif
731 };
732 
733 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
734   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
735  
736   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
737 
738   vec3 position;
739   
740   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
741   position = unpackHighpData(s.position, s.position_fract_part);
742   #else
743   position = s.position;
744   #endif
745 
746   vec3 N = normalize(s.normal);
747   vec3 V = normalize(cc_cameraPos.xyz - position);
748 
749   float NV = max(abs(dot(N, V)), 0.0);
750   specular = BRDFApprox(specular, s.roughness, NV);
751 
752   vec3 L = normalize(-cc_mainLitDir.xyz);
753   vec3 H = normalize(L + V);
754   float NH = max(dot(N, H), 0.0);
755   float NL = max(dot(N, L), 0.0);
756   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
757   vec3 diffuseContrib = diffuse / PI;
758   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
759   vec3 dirlightContrib = (diffuseContrib + specularContrib);
760 
761   float shadow = 1.0;
762   #if CC_RECEIVE_SHADOW
763     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
764       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
765     }
766   #endif
767 
768   dirlightContrib *= shadow;
769   finalColor *= dirlightContrib;
770 
771   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
772     if (s.lightmap_test > EPSILON_LOWP) {
773       finalColor = diffuse * s.lightmap.rgb * shadow;
774     }
775   #endif
776 
777   float fAmb = 0.5 - N.y * 0.5;
778   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
779 
780 
781   #if CC_USE_IBL
782     #if CC_USE_DIFFUSEMAP
783       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
784       #if CC_USE_DIFFUSEMAP == 2
785         ambDiff = unpackRGBE(diffuseMap);
786       #else
787         ambDiff = SRGBToLinear(diffuseMap.rgb);
788       #endif
789     #endif
790 
791     vec3 R = normalize(reflect(-V, N));
792 
793     #if USE_REFLECTION_DENOISE
794       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
795     #else
796       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
797 
798       #if CC_USE_IBL == 2
799         vec3 env = unpackRGBE(envmap);
800       #else
801         vec3 env = SRGBToLinear(envmap.rgb);
802       #endif
803     #endif
804 
805     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
806   #endif
807 
808   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
809   
810 
811   finalColor += s.emissive;
812 
813   return vec4(finalColor, s.albedo.a);
814 }
815 
816 
817 
818 vec3 ACESToneMap (vec3 color) {
819   color = min(color, vec3(8.0));
820   const float A = 2.51;
821   const float B = 0.03;
822   const float C = 2.43;
823   const float D = 0.59;
824   const float E = 0.14;
825   return (color * (A * color + B)) / (color * (C * color + D) + E);
826 }
827 
828 
829 
830 vec4 CCFragOutput (vec4 color) {
831   #if CC_USE_HDR
832     color.rgb = ACESToneMap(color.rgb);
833   #endif
834   color.rgb = sqrt(color.rgb);
835   return color;
836 }
837 
838 
839 
840 
841 varying highp vec4 v_shadowPos;
842 
843 
844 
845 #if CC_RECEIVE_SHADOW
846 
847 
848 
849 #endif
850 
851 
852 
853 
854 #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
855   varying vec3 v_luv;
856   uniform sampler2D cc_lightingMap;
857   
858 #endif
859 
860 void alphaTestFunc(float alpha)
861 {
862   if (alpha < albedoScaleAndCutoff.w) discard;
863 }
864 
865 
866 varying vec3 v_position;
867 varying vec2 v_uv;
868 varying vec2 v_uv1;
869 varying vec3 v_normal;
870 varying vec3 v_tangent;
871 varying vec3 v_bitangent;
872 
873 varying vec4 worldViewDir;
874 varying vec4 worldHalfDir;
875 
876 #if USE_VERTEX_COLOR
877   varying vec4 v_color;
878 #endif
879 
880 #if USE_ALBEDO_MAP
881   uniform sampler2D albedoMap;
882   #endif
883 #if USE_NORMAL_MAP
884   uniform sampler2D normalMap;
885   #endif
886 #if USE_PBR_MAP
887   uniform sampler2D pbrMap;
888 #endif
889 #if USE_METALLIC_ROUGHNESS_MAP
890   uniform sampler2D metallicRoughnessMap;
891 #endif
892 #if USE_OCCLUSION_MAP
893   uniform sampler2D occlusionMap;
894 #endif
895 #if USE_EMISSIVE_MAP
896   uniform sampler2D emissiveMap;
897   #endif
898 
899 #define OCCLUSION_CHANNEL r
900 #define ROUGHNESS_CHANNEL g
901 #define METALLIC_CHANNEL  b
902 #define SPECULARINTENSITY_CHANNEL w
903 
904 
905 #if USE_ALPHA_TEST
906   #endif
907 
908 #if USE_ANISOTROPY
909   uniform sampler2D anisoRamp;
910 #endif
911 
912 float anisotropyIndex( float offset, float factor, float amt ) {
913   vec3 jitterN = v_bitangent + (v_normal * offset + factor);
914   float NHdot = dot(normalize(jitterN), normalize(worldHalfDir.xyz));
915   float sinNH = max(0.01, sqrt(1.0 - pow(NHdot, 2.0)));
916   float atten = smoothstep(-1.0, 0.0, NHdot);
917   return pow(sinNH, amt) * atten;
918 }
919 
920 void surf (out StandardSurface s) {
921   vec4 baseColor = albedo;
922 
923   #if USE_VERTEX_COLOR
924     baseColor.rgb *= SRGBToLinear(v_color.rgb);
925     baseColor.a *= v_color.a;
926   #endif
927 
928   #if USE_ALBEDO_MAP
929     vec4 texColor = texture2D(albedoMap, options([v_uv, v_uv1]));
930     texColor.rgb = SRGBToLinear(texColor.rgb);
931     baseColor *= texColor;
932   #endif
933 
934   s.albedo = baseColor;
935   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
936 
937   #if USE_ALPHA_TEST
938     alphaTestFunc(s.albedo.options([a, r]));
939   #endif
940 
941   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
942     vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);
943     s.lightmap = UnpackLightingmap(lightColor);
944     s.lightmap_test = v_luv.z; 
945   #endif
946 
947   s.normal = v_normal;
948   #if USE_NORMAL_MAP
949     vec3 nmmp = texture2D(normalMap, options([v_uv, v_uv1])).xyz - vec3(0.5);
950     s.normal =
951       (nmmp.x * miscParams.x) * normalize(v_tangent) +
952       (nmmp.y * miscParams.x) * normalize(v_bitangent) +
953       nmmp.z * normalize(s.normal);
954   #endif
955 
956   s.position = v_position;
957 
958   vec4 pbr = pbrParams;
959   #if USE_PBR_MAP
960     vec4 res = texture2D(pbrMap, options([v_uv, v_uv1]));
961     pbr.x *= res.OCCLUSION_CHANNEL;
962     pbr.y *= res.ROUGHNESS_CHANNEL;
963     pbr.z *= res.METALLIC_CHANNEL;
964     pbr.w *= res.SPECULARINTENSITY_CHANNEL;
965   #endif
966 
967   #if USE_METALLIC_ROUGHNESS_MAP
968     vec4 metallicRoughness = texture2D(metallicRoughnessMap, options([v_uv, v_uv1]));
969     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
970     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
971   #endif
972 
973   #if USE_OCCLUSION_MAP
974     pbr.x *= texture2D(occlusionMap, options([v_uv, v_uv1])).OCCLUSION_CHANNEL;
975   #endif
976   s.occlusion = clamp(pbr.x, 0.0, 0.96);
977   s.roughness = clamp(pbr.y, 0.04, 1.0);
978   s.metallic = pbr.z;
979 
980   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
981   #if USE_EMISSIVE_MAP
982     s.emissive *= SRGBToLinear(texture2D(emissiveMap, options([v_uv, v_uv1])).rgb);
983   #endif
984 
985   #if USE_ANISOTROPY
986     vec2 anisoUV = v_uv * anisoTile.xy + anisoTile.zw;
987     vec4 anisoMap = texture2D(anisoRamp, anisoUV);
988     float jitterFactor = anisoMap.r * anisoJitter.x + anisoMap.g * anisoJitter.y;
989     float aoFactor = mix(1.0, 0.0, anisoAOStrength * pbr.x);
990 
991     vec4 hairSpec = clamp((anisotropyIndex(hairSpecMOffset, jitterFactor, hairSpecMAmt) * hairSpecColor01 * hairSpecIntensity + anisotropyIndex(hairSpecAOffset, jitterFactor, hairSpecAAmt) * hairSpecColor02 * hairSpecIntensity) *
992                           aoFactor *
993                           pow((1.0 - dot(v_normal, worldViewDir.xyz)), 2.25),
994                           0.0, 1.51);
995 
996     s.albedo.rgb += hairBaseColor.rgb + hairSpec.rgb;
997   #endif
998 }
999 
1000 
1001 #if CC_FORWARD_ADD                                                 
1002                                
1003                                
1004                                
1005   #if CC_PIPELINE_TYPE == 0                             
1006     #define LIGHTS_PER_PASS 1                             
1007   #else                             
1008     #define LIGHTS_PER_PASS 10                             
1009   #endif                             
1010                                
1011   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1012   uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];
1013   uniform vec4 cc_lightColor[LIGHTS_PER_PASS];
1014   uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];
1015   uniform vec4 cc_lightDir[LIGHTS_PER_PASS];
1016                              
1017   #endif                             
1018                                
1019                                
1020                                
1021                                
1022   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {                             
1023     float factor = distSqr * invSqrAttRadius;                             
1024     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);                             
1025     return smoothFactor * smoothFactor;                             
1026   }                             
1027                                
1028   float GetDistAtt (float distSqr, float invSqrAttRadius) {                             
1029     float attenuation = 1.0 / max(distSqr, 0.01*0.01);                             
1030     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);                             
1031     return attenuation;                             
1032   }                             
1033                                
1034   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {                             
1035     float cd = dot(litDir, L);                             
1036     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);                             
1037     return (attenuation * attenuation);                             
1038   }                             
1039                                
1040                                
1041   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1042   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {                             
1043     vec3 position;                             
1044     
1045     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1046     position = unpackHighpData(s.position, s.position_fract_part);
1047     #else
1048     position = s.position;
1049     #endif
1050     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                             
1051     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                             
1052     vec3 diffuseContrib = diffuse / PI;                             
1053                                
1054     vec3 N = normalize(s.normal);                             
1055     vec3 V = normalize(cc_cameraPos.xyz - position);                             
1056     float NV = max(abs(dot(N, V)), 0.0);                             
1057     specular = BRDFApprox(specular, s.roughness, NV);                             
1058     vec3 finalColor = vec3(0.0);                             
1059                                
1060     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);                             
1061                                
1062     for (int i = 0; i < LIGHTS_PER_PASS; i++) {                             
1063       if (i >= numLights) break;                             
1064       vec3 SLU = cc_lightPos[i].xyz - position;                             
1065       vec3 SL = normalize(SLU);                             
1066       vec3 SH = normalize(SL + V);                             
1067       float SNL = max(dot(N, SL), 0.0);                             
1068       float SNH = max(dot(N, SH), 0.0);                             
1069                                
1070       float distSqr = dot(SLU, SLU);                             
1071       float litRadius = cc_lightSizeRangeAngle[i].x;                             
1072       float litRadiusSqr = litRadius * litRadius;                             
1073       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);                             
1074       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);                             
1075       attRadiusSqrInv *= attRadiusSqrInv;                             
1076       float att = GetDistAtt(distSqr, attRadiusSqrInv);                             
1077       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                             
1078                                
1079       if (cc_lightPos[i].w > 0.0) {                             
1080         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);                             
1081         float cosOuter = cc_lightSizeRangeAngle[i].z;                             
1082         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                             
1083         float litAngleOffset = -cosOuter * litAngleScale;                             
1084         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);                             
1085       }                             
1086                                
1087       vec3 lightColor = cc_lightColor[i].rgb;                             
1088                                
1089       float shadow = 1.0;                             
1090       #if CC_RECEIVE_SHADOW                             
1091         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {                             
1092           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                             
1093         }                             
1094       #endif                             
1095                                
1096       lightColor *= shadow;                             
1097       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);                             
1098     }                             
1099                                
1100     return vec4(finalColor, 0.0);                             
1101   }                             
1102   #endif                             
1103                                
1104   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                       
1105   readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };                              
1106   readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };                              
1107   readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };                              
1108                                 
1109   struct CCLight                              
1110   {                              
1111     vec4 cc_lightPos;                              
1112     vec4 cc_lightColor;                              
1113     vec4 cc_lightSizeRangeAngle;                              
1114     vec4 cc_lightDir;                              
1115   };                              
1116                                 
1117   struct Cluster                              
1118   {                              
1119     vec3 minBounds;                              
1120     vec3 maxBounds;                              
1121   };                              
1122                                 
1123   struct LightGrid                              
1124   {                              
1125     uint offset;                              
1126     uint ccLights;                              
1127   };                              
1128                                 
1129                                 
1130                                 
1131   CCLight getCCLight(uint i)                              
1132   {                              
1133     CCLight light;                              
1134     light.cc_lightPos = b_ccLights[4u * i + 0u];                              
1135     light.cc_lightColor = b_ccLights[4u * i + 1u];                              
1136     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];                              
1137     light.cc_lightDir = b_ccLights[4u * i + 3u];                              
1138     return light;                              
1139   }                              
1140                                 
1141   LightGrid getLightGrid(uint cluster)                              
1142   {                              
1143     uvec4 gridvec = b_clusterLightGrid[cluster];                              
1144     LightGrid grid;                              
1145     grid.offset = gridvec.x;                              
1146     grid.ccLights = gridvec.y;                              
1147     return grid;                              
1148   }                              
1149                                 
1150   uint getGridLightIndex(uint start, uint offset)                              
1151   {                              
1152     return b_clusterLightIndices[start + offset];                              
1153   }                              
1154                                 
1155   uint getClusterZIndex(vec4 worldPos)                              
1156   {                              
1157     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);                              
1158     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));                              
1159     float eyeDepth = -(cc_matView * worldPos).z;                              
1160     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));                              
1161     return zIndex;                              
1162   }                              
1163                                 
1164   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)                              
1165   {                              
1166     uint zIndex = getClusterZIndex(worldPos);                              
1167     float clusterSizeX = ceil(cc_viewPort.z / float(16));                              
1168     float clusterSizeY = ceil(cc_viewPort.w / float(8));                              
1169     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);                              
1170     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;                              
1171     return cluster;                              
1172   }                              
1173                                 
1174   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {                              
1175     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                              
1176     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                              
1177     vec3 diffuseContrib = diffuse / PI;                              
1178                                 
1179     vec3 position;                              
1180     
1181     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1182     position = unpackHighpData(s.position, s.position_fract_part);
1183     #else
1184     position = s.position;
1185     #endif
1186                                 
1187     vec3 N = normalize(s.normal);                              
1188     vec3 V = normalize(cc_cameraPos.xyz - position);                              
1189     float NV = max(abs(dot(N, V)), 0.001);                              
1190     specular = BRDFApprox(specular, s.roughness, NV);                              
1191     vec3 finalColor = vec3(0.0);                              
1192                                 
1193     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));                              
1194     LightGrid grid = getLightGrid(cluster);                              
1195     uint numLights = grid.ccLights;                              
1196                                 
1197     for (uint i = 0u; i < 100u; i++) {                              
1198       if (i >= numLights) break;                              
1199       uint lightIndex = getGridLightIndex(grid.offset, i);                              
1200       CCLight light = getCCLight(lightIndex);                              
1201       vec3 SLU = light.cc_lightPos.xyz - position;                              
1202       vec3 SL = normalize(SLU);                              
1203       vec3 SH = normalize(SL + V);                              
1204       float SNL = max(dot(N, SL), 0.001);                              
1205       float SNH = max(dot(N, SH), 0.0);                              
1206                                 
1207       float distSqr = dot(SLU, SLU);                              
1208       float litRadius = light.cc_lightSizeRangeAngle.x;                              
1209       float litRadiusSqr = litRadius * litRadius;                              
1210       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));                              
1211       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);                              
1212       attRadiusSqrInv *= attRadiusSqrInv;                              
1213       float att = GetDistAtt(distSqr, attRadiusSqrInv);                              
1214       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                              
1215                                 
1216       if (light.cc_lightPos.w > 0.0) {                              
1217         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);                              
1218         float cosOuter = light.cc_lightSizeRangeAngle.z;                              
1219         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                              
1220         float litAngleOffset = -cosOuter * litAngleScale;                              
1221         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);                              
1222       }                              
1223                                 
1224       vec3 lightColor = light.cc_lightColor.rgb;                              
1225                                 
1226       float shadow = 1.0;                              
1227       #if CC_RECEIVE_SHADOW                              
1228         if (light.cc_lightPos.w > 0.0) {                              
1229           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                              
1230         }                              
1231       #endif                              
1232                                 
1233       lightColor *= shadow;                              
1234       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);                              
1235     }                              
1236                                 
1237     return vec4(finalColor, 0.0);                              
1238   }                              
1239                                 
1240   #endif                                                           
1241                                                                    
1242                           
1243                                                                    
1244   void main () {                                                   
1245     StandardSurface s; surf(s);                                    
1246     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                     
1247     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);  
1248     #else                                                          
1249     vec4 color = CCStandardShadingAdditive(s, v_shadowPos); 
1250     #endif                                                         
1251     gl_FragData[0] = CCFragOutput(color);                              
1252   }                                                                
1253                                                                    
1254 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING) 
1255                                                                    
1256                           
1257                                                                    
1258   void main () {                                                   
1259     StandardSurface s; surf(s);                                    
1260     vec4 color = CCStandardShadingBase(s, v_shadowPos);     
1261     CC_APPLY_FOG(color, s.position.xyz);                           
1262     gl_FragData[0] = CCFragOutput(color);                              
1263   }                                                                
1264                                                                    
1265 #elif CC_PIPELINE_TYPE == 1                
1266                                     
1267   vec2 signNotZero(vec2 v) {                                  
1268     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);                                  
1269   }                                  
1270   vec2 float32x3_to_oct(in vec3 v) {                                  
1271     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));                                  
1272     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;                                  
1273   }                                  
1274                                     
1275                                     
1276                                     
1277                                     
1278                                                                    
1279                           
1280                           
1281                           
1282                                                                    
1283   void main () {                                                   
1284     StandardSurface s; surf(s);                                    
1285     gl_FragData[0] = s.albedo;                                         
1286     gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic); 
1287     gl_FragData[2] = vec4(s.emissive, s.occlusion);                    
1288   }                                                                
1289                                                                    
1290 #endif                                                             
1291 [Asset DB] ../test/builtin-standard-anisotropy-001.effect - standard-fs: Error EFX2406: compilation failed: ↓↓↓↓↓ EXPAND THIS MESSAGE FOR MORE INFO ↓↓↓↓↓
ERROR: 0:929: '[' : syntax error
 

1 #version 100
2 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1
3 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024
4 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024
5 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128
6 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128
7 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0
8 #define CC_PLATFORM_ANDROID_AND_WEBGL 0
9 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0
10 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0
11 #define USE_INSTANCING 1
12 #define USE_LIGHTMAP 1
13 #define CC_RECEIVE_SHADOW 1
14 #define USE_BATCHING 1
15 #define CC_USE_MORPH 1
16 #define CC_USE_SKINNING 1
17 #define CC_MORPH_TARGET_COUNT 2
18 #define CC_MORPH_PRECOMPUTED 1
19 #define CC_MORPH_TARGET_HAS_POSITION 1
20 #define CC_MORPH_TARGET_HAS_NORMAL 1
21 #define CC_MORPH_TARGET_HAS_TANGENT 1
22 #define CC_USE_BAKED_ANIMATION 1
23 #define CC_USE_FOG 0
24 #define CC_USE_ACCURATE_FOG 1
25 #define USE_VERTEX_COLOR 1
26 #define HAS_SECOND_UV 1
27 #define CC_FORWARD_ADD 1
28 #define USE_NORMAL_MAP 1
29 #define SAMPLE_FROM_RT 1
30 #define CC_USE_IBL 0
31 #define CC_USE_DIFFUSEMAP 0
32 #define USE_REFLECTION_DENOISE 1
33 #define CC_USE_HDR 1
34 #define USE_ALBEDO_MAP 1
35 #define USE_PBR_MAP 1
36 #define USE_METALLIC_ROUGHNESS_MAP 1
37 #define USE_OCCLUSION_MAP 1
38 #define USE_EMISSIVE_MAP 1
39 #define USE_ALPHA_TEST 1
40 #define USE_ANISOTROPY 1
41 #define CC_PIPELINE_TYPE 0
42 #define CC_FORCE_FORWARD_SHADING 1
43 
44 #ifdef GL_EXT_draw_buffers
45 #extension GL_EXT_draw_buffers: enable
46 #endif
47 
48 #ifdef GL_OES_standard_derivatives
49 #extension GL_OES_standard_derivatives: enable
50 #endif
51 
52 #ifdef GL_EXT_shader_texture_lod
53 #extension GL_EXT_shader_texture_lod: enable
54 #endif
55 
56 precision highp float;
57 uniform highp mat4 cc_matView;
58   uniform highp vec4 cc_cameraPos;
59   uniform mediump vec4 cc_mainLitDir;
60   uniform mediump vec4 cc_mainLitColor;
61   uniform mediump vec4 cc_ambientSky;
62   uniform mediump vec4 cc_ambientGround;
63   uniform mediump vec4 cc_fogColor;
64   uniform mediump vec4 cc_fogBase;
65   uniform mediump vec4 cc_fogAdd;
66   uniform mediump vec4 cc_nearFar;
67   uniform mediump vec4 cc_viewPort;
68 
69 
70 
71      uniform vec4 albedo;
72      uniform vec4 albedoScaleAndCutoff;
73      uniform vec4 pbrParams;
74      uniform vec4 miscParams;
75      uniform vec4 emissive;
76      uniform vec4 emissiveScaleParam;
77      uniform vec4 anisoTile;
78      uniform vec4 hairBaseColor;
79      uniform vec4 hairSpecColor01;
80      uniform vec4 hairSpecColor02;
81      uniform vec2 anisoJitter;
82      uniform float anisoAOStrength;
83      uniform float hairSpecMOffset;
84      uniform float hairSpecAOffset;
85      uniform float hairSpecMAmt;
86      uniform float hairSpecAAmt;
87      uniform float hairSpecIntensity;
88 
89 float LinearFog(vec4 pos) {
90   vec4 wPos = pos;
91   float cam_dis = distance(cc_cameraPos, wPos);
92   float fogStart = cc_fogBase.x;
93   float fogEnd = cc_fogBase.y;
94   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);
95 }
96 
97 float ExpFog(vec4 pos) {
98   vec4 wPos = pos;
99   float fogAtten = cc_fogAdd.z;
100   float fogStart = cc_fogBase.x;
101   float fogDensity = cc_fogBase.z;
102   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
103   float f = exp(-cam_dis * fogDensity);
104   return f;
105 }
106 
107 float ExpSquaredFog(vec4 pos) {
108   vec4 wPos = pos;
109   float fogAtten = cc_fogAdd.z;
110   float fogStart = cc_fogBase.x;
111   float fogDensity = cc_fogBase.z;
112   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;
113   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);
114   return f;
115 }
116 
117 float LayeredFog(vec4 pos) {
118   vec4 wPos = pos;
119   float fogAtten = cc_fogAdd.z;
120   float _FogTop = cc_fogAdd.x;
121   float _FogRange = cc_fogAdd.y;
122   vec3 camWorldProj = cc_cameraPos.xyz;
123   camWorldProj.y = 0.;
124   vec3 worldPosProj = wPos.xyz;
125   worldPosProj.y = 0.;
126   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;
127   float fDeltaY, fDensityIntegral;
128   if (cc_cameraPos.y > _FogTop) {
129     if (wPos.y < _FogTop) {
130       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;
131       fDensityIntegral = fDeltaY * fDeltaY * 0.5;
132     } else {
133       fDeltaY = 0.;
134       fDensityIntegral = 0.;
135     }
136   } else {
137     if (wPos.y < _FogTop) {
138       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;
139       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;
140       fDeltaY = abs(fDeltaA - fDeltaB);
141       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));
142     } else {
143       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;
144       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);
145     }
146   }
147   float fDensity;
148   if (fDeltaY != 0.) {
149     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;
150   } else {
151     fDensity = 0.;
152   }
153   float f = exp(-fDensity);
154   return f;
155 }
156 
157 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)
158 {
159   #if CC_USE_FOG == 0
160 	factor = LinearFog(pos);
161   #elif CC_USE_FOG == 1
162     factor = ExpFog(pos);
163   #elif CC_USE_FOG == 2
164     factor = ExpSquaredFog(pos);
165   #elif CC_USE_FOG == 3
166     factor = LayeredFog(pos);
167   #else
168     factor = 1.0;
169   #endif
170 }
171 
172 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {
173   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);
174 }
175 
176 
177 #if !CC_USE_ACCURATE_FOG
178 varying float v_fog_factor;
179 #endif
180 
181 void CC_APPLY_FOG(inout vec4 color) {
182 #if !CC_USE_ACCURATE_FOG
183     CC_APPLY_FOG_BASE(color, v_fog_factor);
184 #endif
185 }
186 
187 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {
188 #if CC_USE_ACCURATE_FOG
189     float factor;
190     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);
191 #else
192     float factor = v_fog_factor;
193 #endif
194     CC_APPLY_FOG_BASE(color, factor);
195 }
196 
197 vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {
198   
199     #ifdef GL_EXT_shader_texture_lod
200       return texture2DLodEXT(tex, coord, lod);
201     #else
202       return texture2D(tex, coord, lod);
203     #endif
204   
205 }
206 
207 vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {
208   
209     #ifdef GL_EXT_shader_texture_lod
210       return textureCubeLodEXT(tex, coord, lod);
211     #else
212       return textureCube(tex, coord, lod);
213     #endif
214   
215 }
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 #define QUATER_PI         0.78539816340
228 #define HALF_PI           1.57079632679
229 #define PI                3.14159265359
230 #define PI2               6.28318530718
231 #define PI4               12.5663706144
232      
233 #define INV_QUATER_PI     1.27323954474
234 #define INV_HALF_PI       0.63661977237
235 #define INV_PI            0.31830988618
236 #define INV_PI2           0.15915494309
237 #define INV_PI4           0.07957747155
238      
239 #define EPSILON           1e-6
240 #define EPSILON_LOWP      1e-4
241 #define LOG2              1.442695
242 #define EXP_VALUE         2.71828183f
243 #define FP_MAX            65504.0
244 #define FP_SCALE          0.0009765625
245 #define FP_SCALE_INV      1024.0
246 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)
247 
248 
249 
250 
251 
252 
253 
254 vec3 SRGBToLinear (vec3 gamma) {
255   return gamma * gamma;
256 }
257 uniform highp mat4 cc_matLightView;
258   uniform highp vec4 cc_shadowInvProjDepthInfo;
259   uniform highp vec4 cc_shadowProjDepthInfo;
260   uniform highp vec4 cc_shadowProjInfo;
261   uniform mediump vec4 cc_shadowNFLSInfo;
262   uniform mediump vec4 cc_shadowWHPBInfo;
263   uniform mediump vec4 cc_shadowLPNNInfo;
264 
265 
266 
267 
268 
269 
270 
271 
272 highp float unpackHighpData (float mainPart, float modPart) {
273   highp float data = mainPart;
274   return data + modPart;
275 }
276 
277 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {
278   highp float data = mainPart * modValue;
279   return data + modPart * modValue;
280 }
281 
282 
283 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {
284   highp vec2 data = mainPart;
285   return data + modPart;
286 }
287 
288 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {
289   highp vec2 data = mainPart * modValue;
290   return data + modPart * modValue;
291 }
292 
293 
294 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {
295   highp vec3 data = mainPart;
296   return data + modPart;
297 }
298 
299 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {
300   highp vec3 data = mainPart * modValue;
301   return data + modPart * modValue;
302 }
303 
304 
305 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {
306   highp vec4 data = mainPart;
307   return data + modPart;
308 }
309 
310 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {
311   highp vec4 data = mainPart * modValue;
312   return data + modPart * modValue;
313 }
314 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {
315   float dist = length(viewPos);
316   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);
317 }
318 
319 float CCGetLinearDepth(vec3 worldPos) {
320   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);
321   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);
322 }
323 
324 
325 
326 #if CC_RECEIVE_SHADOW
327   uniform highp sampler2D cc_shadowMap;
328   uniform highp sampler2D cc_spotLightingMap;
329 
330   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)
331   {
332     vec4 newShadowPos = shadowPos;
333     if(normalBias > EPSILON_LOWP)
334     {
335       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);
336       if(viewNormal.z < 0.1)
337         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);
338     }
339     return newShadowPos;
340   }
341   
342   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)
343   {
344     vec3 viewSpacePos;
345     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;
346     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;
347     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;
348     vec4 clipSpacePos;
349     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;
350     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);
351     if (cc_shadowNFLSInfo.z > EPSILON) {
352       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);
353       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;
354     }
355 
356     return clipSpacePos;
357   }
358 
359   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)
360   {
361     float coeffA = cc_shadowProjDepthInfo.x;
362     float coeffB = cc_shadowProjDepthInfo.y;
363     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;
364     viewSpacePos_z += viewspaceDepthBias;
365     vec4 result = shadowPos;
366     result.z = viewSpacePos_z * coeffA + coeffB;
367     return result;
368   }
369   
370   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {
371     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
372     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
373     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
374         clipPos.y < 0.0 || clipPos.y > 1.0 ||
375         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
376     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
377 
378     float shadow = 0.0;
379     float closestDepth = 0.0;
380     if (cc_shadowLPNNInfo.y > EPSILON) {
381       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
382     } else {
383       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;
384     }
385     shadow = step(clipPos.z, closestDepth);
386 
387     return shadow;
388   }
389 
390   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {
391     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
392     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
393     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
394         clipPos.y < 0.0 || clipPos.y > 1.0 ||
395         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
396     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
397 
398     float offsetDepth = clipPos.z;
399     vec2 mapSize = cc_shadowWHPBInfo.xy;
400     vec2 oneTap = 1.0 / mapSize;
401     vec2 clipPos_offset = clipPos.xy + oneTap;
402 
403     float block0, block1, block2, block3;
404     if (cc_shadowLPNNInfo.y > EPSILON) {
405       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
406       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
407       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
408       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
409     } else {
410       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
411       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);
412       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);
413       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
414     }
415 
416     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;
417     float resultX = mix(block0, block1, coefX);
418     float resultY = mix(block2, block3, coefX);
419     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;
420 
421     return mix(resultX, resultY, coefY);
422   }
423 
424   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {
425     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);
426     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
427     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
428         clipPos.y < 0.0 || clipPos.y > 1.0 ||
429         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
430     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
431 
432     float offsetDepth = clipPos.z;
433     vec2 mapSize = cc_shadowWHPBInfo.xy;
434     vec2 oneTap = 1.0 / mapSize;
435     float clipPos_offset_L = clipPos.x - oneTap.x;
436     float clipPos_offset_R = clipPos.x + oneTap.x;
437     float clipPos_offset_U = clipPos.y - oneTap.y;
438     float clipPos_offset_D = clipPos.y + oneTap.y;
439 
440     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
441     if (cc_shadowLPNNInfo.y > EPSILON) {
442       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
443       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
444       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
445       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
446       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
447       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
448       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
449       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
450       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
451     } else {
452       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
453       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);
454       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
455       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);
456       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);
457       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);
458       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
459       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);
460       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
461     }
462 
463     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
464     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
465 
466     float shadow = 0.0;
467     float resultX = mix(block0, block1, coefX);
468     float resultY = mix(block3, block4, coefX);
469     shadow += mix(resultX , resultY, coefY);
470 
471     resultX = mix(block1, block2, coefX);
472     resultY = mix(block4, block5, coefX);
473     shadow += mix(resultX , resultY, coefY);
474 
475     resultX = mix(block3, block4, coefX);
476     resultY = mix(block6, block7, coefX);
477     shadow += mix(resultX, resultY, coefY);
478 
479     resultX = mix(block4, block5, coefX);
480     resultY = mix(block7, block8, coefX);
481     shadow += mix(resultX, resultY, coefY);
482 
483     return shadow * 0.25;
484   }
485 
486   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {
487     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
488     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
489     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
490         clipPos.y < 0.0 || clipPos.y > 1.0 ||
491         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
492     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
493 
494     float shadow = 0.0;
495     float closestDepth = 0.0;
496     float depth = clipPos.z;
497 
498     if (cc_shadowLPNNInfo.y > EPSILON) {
499       closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
500     } else {
501       closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;
502     }
503     shadow = step(depth, closestDepth);
504 
505     return shadow;
506   }
507 
508   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {
509     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
510     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
511     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
512         clipPos.y < 0.0 || clipPos.y > 1.0 ||
513         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
514     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
515 
516     float depth = 0.0;
517     if (cc_shadowNFLSInfo.z > EPSILON) {
518       depth = CCGetLinearDepth(worldPos);
519     } else {
520       depth = clipPos.z;
521     }
522 
523     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;
524     vec2 clipPos_offset = clipPos.xy + oneTap;
525 
526     float block0, block1, block2, block3;
527     if (cc_shadowLPNNInfo.y > EPSILON) {
528       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
529       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
530       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
531       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
532     } else {
533       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
534       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);
535       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);
536       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);
537     }
538 
539     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;
540     float resultX = mix(block0, block1, coefX);
541     float resultY = mix(block2, block3, coefX);
542     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;
543 
544     return mix(resultX, resultY, coefY);
545   }
546 
547   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {
548     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);
549     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;
550     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||
551         clipPos.y < 0.0 || clipPos.y > 1.0 ||
552         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }
553     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;
554 
555     float depth = 0.0;
556     if (cc_shadowNFLSInfo.z > EPSILON) {
557       depth = CCGetLinearDepth(worldPos);
558     } else {
559       depth = clipPos.z;
560     }
561 
562     vec2 mapSize = cc_shadowWHPBInfo.xy;
563     vec2 oneTap = 1.0 / mapSize;
564     float clipPos_offset_L = clipPos.x - oneTap.x;
565     float clipPos_offset_R = clipPos.x + oneTap.x;
566     float clipPos_offset_U = clipPos.y - oneTap.y;
567     float clipPos_offset_D = clipPos.y + oneTap.y;
568 
569     float block0, block1, block2, block3, block4, block5, block6, block7, block8;
570     if (cc_shadowLPNNInfo.y > EPSILON) {
571       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
572       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
573       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
574       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
575       block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
576       block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
577       block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
578       block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
579       block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));
580     } else {
581       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);
582       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);
583       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);
584       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);
585       block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);
586       block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);
587       block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);
588       block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);
589       block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);
590     }
591 
592     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;
593     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;
594 
595     float shadow = 0.0;
596     float resultX = mix(block0, block1, coefX);
597     float resultY = mix(block3, block4, coefX);
598     shadow += mix(resultX , resultY, coefY);
599 
600     resultX = mix(block1, block2, coefX);
601     resultY = mix(block4, block5, coefX);
602     shadow += mix(resultX , resultY, coefY);
603 
604     resultX = mix(block3, block4, coefX);
605     resultY = mix(block6, block7, coefX);
606     shadow += mix(resultX, resultY, coefY);
607 
608     resultX = mix(block4, block5, coefX);
609     resultY = mix(block7, block8, coefX);
610     shadow += mix(resultX, resultY, coefY);
611 
612     return shadow * 0.25;
613   }
614 
615 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)
616 {
617   float pcf = cc_shadowWHPBInfo.z;
618   if (pcf > 1.9) { 
619     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);
620   }else if (pcf > 0.9) { 
621     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);
622   }else { 
623     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x); 
624   }
625 }
626 
627 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)
628 {
629   float realtimeShadow = 1.0;
630   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);
631   
632   float pcf = cc_shadowWHPBInfo.z;
633   if (pcf > 1.9) { 
634     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);
635   }else if (pcf > 0.9) {
636     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);
637   }else { 
638     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x); 
639   }
640   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);
641 }
642 #endif
643 
644 
645 
646 #if CC_USE_IBL
647   uniform samplerCube cc_environment;
648   
649 
650   
651   
652   vec3 unpackRGBE (vec4 rgbe) {
653     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);
654   }
655   
656 
657   #if CC_USE_DIFFUSEMAP
658     uniform samplerCube cc_diffuseMap;
659   #endif
660 #endif
661 
662 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {
663   vec3 NxH = cross(N, H);
664   float OneMinusNoHSqr = dot(NxH, NxH);
665   float a = roughness * roughness;
666   float n = NoH * a;
667   float p = a / (OneMinusNoHSqr + n * n);
668   return p * p;
669 }
670 
671 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {
672   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);
673 }
674 
675 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {
676   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);
677   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);
678   vec4 r = roughness * c0 + c1;
679   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
680   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
681   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);
682   return specular * AB.x + AB.y;
683 }
684 
685 #if USE_REFLECTION_DENOISE
686   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {
687     #if CC_USE_IBL
688     	float mip = roughness * mipCount;
689     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;
690     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));
691 
692     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);
693      	vec4 filtered = textureCube(cc_environment, R);
694 
695       #if CC_USE_IBL == 2
696       	biased.rgb = unpackRGBE(biased);
697       	filtered.rgb = unpackRGBE(filtered);
698       #else
699       	biased.rgb = SRGBToLinear(biased.rgb);
700       	filtered.rgb = SRGBToLinear(filtered.rgb);
701       #endif
702       	
703       return mix(biased.rgb, filtered.rgb, denoiseIntensity);
704     #else
705       return vec3(0.0, 0.0, 0.0);
706     #endif
707   }
708 #endif
709 
710 
711 struct StandardSurface {
712   vec4 albedo;
713   
714   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
715   vec3 position, position_fract_part;
716   #else
717   vec3 position;
718   #endif
719   vec3 normal;
720   vec3 emissive;
721   vec3 lightmap;
722   float lightmap_test;
723   float roughness;
724   float metallic;
725   float occlusion;
726   float specularIntensity;
727 
728   #if CC_RECEIVE_SHADOW
729     vec2 shadowBias;
730   #endif
731 };
732 
733 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {
734   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);
735  
736   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);
737 
738   vec3 position;
739   
740   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
741   position = unpackHighpData(s.position, s.position_fract_part);
742   #else
743   position = s.position;
744   #endif
745 
746   vec3 N = normalize(s.normal);
747   vec3 V = normalize(cc_cameraPos.xyz - position);
748 
749   float NV = max(abs(dot(N, V)), 0.0);
750   specular = BRDFApprox(specular, s.roughness, NV);
751 
752   vec3 L = normalize(-cc_mainLitDir.xyz);
753   vec3 H = normalize(L + V);
754   float NH = max(dot(N, H), 0.0);
755   float NL = max(dot(N, L), 0.0);
756   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;
757   vec3 diffuseContrib = diffuse / PI;
758   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);
759   vec3 dirlightContrib = (diffuseContrib + specularContrib);
760 
761   float shadow = 1.0;
762   #if CC_RECEIVE_SHADOW
763     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {
764       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);
765     }
766   #endif
767 
768   dirlightContrib *= shadow;
769   finalColor *= dirlightContrib;
770 
771   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
772     if (s.lightmap_test > EPSILON_LOWP) {
773       finalColor = diffuse * s.lightmap.rgb * shadow;
774     }
775   #endif
776 
777   float fAmb = 0.5 - N.y * 0.5;
778   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);
779 
780 
781   #if CC_USE_IBL
782     #if CC_USE_DIFFUSEMAP
783       vec4 diffuseMap = textureCube(cc_diffuseMap, N);
784       #if CC_USE_DIFFUSEMAP == 2
785         ambDiff = unpackRGBE(diffuseMap);
786       #else
787         ambDiff = SRGBToLinear(diffuseMap.rgb);
788       #endif
789     #endif
790 
791     vec3 R = normalize(reflect(-V, N));
792 
793     #if USE_REFLECTION_DENOISE
794       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);
795     #else
796       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);
797 
798       #if CC_USE_IBL == 2
799         vec3 env = unpackRGBE(envmap);
800       #else
801         vec3 env = SRGBToLinear(envmap.rgb);
802       #endif
803     #endif
804 
805     finalColor += env * cc_ambientSky.w * specular * s.occlusion;
806   #endif
807 
808   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;
809   
810 
811   finalColor += s.emissive;
812 
813   return vec4(finalColor, s.albedo.a);
814 }
815 
816 
817 
818 vec3 ACESToneMap (vec3 color) {
819   color = min(color, vec3(8.0));
820   const float A = 2.51;
821   const float B = 0.03;
822   const float C = 2.43;
823   const float D = 0.59;
824   const float E = 0.14;
825   return (color * (A * color + B)) / (color * (C * color + D) + E);
826 }
827 
828 
829 
830 vec4 CCFragOutput (vec4 color) {
831   #if CC_USE_HDR
832     color.rgb = ACESToneMap(color.rgb);
833   #endif
834   color.rgb = sqrt(color.rgb);
835   return color;
836 }
837 
838 
839 
840 
841 varying highp vec4 v_shadowPos;
842 
843 
844 
845 #if CC_RECEIVE_SHADOW
846 
847 
848 
849 #endif
850 
851 
852 
853 
854 #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
855   varying vec3 v_luv;
856   uniform sampler2D cc_lightingMap;
857   
858 #endif
859 
860 void alphaTestFunc(float alpha)
861 {
862   if (alpha < albedoScaleAndCutoff.w) discard;
863 }
864 
865 
866 varying vec3 v_position;
867 varying vec2 v_uv;
868 varying vec2 v_uv1;
869 varying vec3 v_normal;
870 varying vec3 v_tangent;
871 varying vec3 v_bitangent;
872 
873 varying vec4 worldViewDir;
874 varying vec4 worldHalfDir;
875 
876 #if USE_VERTEX_COLOR
877   varying vec4 v_color;
878 #endif
879 
880 #if USE_ALBEDO_MAP
881   uniform sampler2D albedoMap;
882   #endif
883 #if USE_NORMAL_MAP
884   uniform sampler2D normalMap;
885   #endif
886 #if USE_PBR_MAP
887   uniform sampler2D pbrMap;
888 #endif
889 #if USE_METALLIC_ROUGHNESS_MAP
890   uniform sampler2D metallicRoughnessMap;
891 #endif
892 #if USE_OCCLUSION_MAP
893   uniform sampler2D occlusionMap;
894 #endif
895 #if USE_EMISSIVE_MAP
896   uniform sampler2D emissiveMap;
897   #endif
898 
899 #define OCCLUSION_CHANNEL r
900 #define ROUGHNESS_CHANNEL g
901 #define METALLIC_CHANNEL  b
902 #define SPECULARINTENSITY_CHANNEL w
903 
904 
905 #if USE_ALPHA_TEST
906   #endif
907 
908 #if USE_ANISOTROPY
909   uniform sampler2D anisoRamp;
910 #endif
911 
912 float anisotropyIndex( float offset, float factor, float amt ) {
913   vec3 jitterN = v_bitangent + (v_normal * offset + factor);
914   float NHdot = dot(normalize(jitterN), normalize(worldHalfDir.xyz));
915   float sinNH = max(0.01, sqrt(1.0 - pow(NHdot, 2.0)));
916   float atten = smoothstep(-1.0, 0.0, NHdot);
917   return pow(sinNH, amt) * atten;
918 }
919 
920 void surf (out StandardSurface s) {
921   vec4 baseColor = albedo;
922 
923   #if USE_VERTEX_COLOR
924     baseColor.rgb *= SRGBToLinear(v_color.rgb);
925     baseColor.a *= v_color.a;
926   #endif
927 
928   #if USE_ALBEDO_MAP
929     vec4 texColor = texture2D(albedoMap, options([v_uv, v_uv1]));
930     texColor.rgb = SRGBToLinear(texColor.rgb);
931     baseColor *= texColor;
932   #endif
933 
934   s.albedo = baseColor;
935   s.albedo.rgb *= albedoScaleAndCutoff.xyz;
936 
937   #if USE_ALPHA_TEST
938     alphaTestFunc(s.albedo.options([a, r]));
939   #endif
940 
941   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD
942     vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);
943     s.lightmap = UnpackLightingmap(lightColor);
944     s.lightmap_test = v_luv.z; 
945   #endif
946 
947   s.normal = v_normal;
948   #if USE_NORMAL_MAP
949     vec3 nmmp = texture2D(normalMap, options([v_uv, v_uv1])).xyz - vec3(0.5);
950     s.normal =
951       (nmmp.x * miscParams.x) * normalize(v_tangent) +
952       (nmmp.y * miscParams.x) * normalize(v_bitangent) +
953       nmmp.z * normalize(s.normal);
954   #endif
955 
956   s.position = v_position;
957 
958   vec4 pbr = pbrParams;
959   #if USE_PBR_MAP
960     vec4 res = texture2D(pbrMap, options([v_uv, v_uv1]));
961     pbr.x *= res.OCCLUSION_CHANNEL;
962     pbr.y *= res.ROUGHNESS_CHANNEL;
963     pbr.z *= res.METALLIC_CHANNEL;
964     pbr.w *= res.SPECULARINTENSITY_CHANNEL;
965   #endif
966 
967   #if USE_METALLIC_ROUGHNESS_MAP
968     vec4 metallicRoughness = texture2D(metallicRoughnessMap, options([v_uv, v_uv1]));
969     pbr.z *= metallicRoughness.METALLIC_CHANNEL;
970     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
971   #endif
972 
973   #if USE_OCCLUSION_MAP
974     pbr.x *= texture2D(occlusionMap, options([v_uv, v_uv1])).OCCLUSION_CHANNEL;
975   #endif
976   s.occlusion = clamp(pbr.x, 0.0, 0.96);
977   s.roughness = clamp(pbr.y, 0.04, 1.0);
978   s.metallic = pbr.z;
979 
980   s.emissive = emissive.rgb * emissiveScaleParam.xyz;
981   #if USE_EMISSIVE_MAP
982     s.emissive *= SRGBToLinear(texture2D(emissiveMap, options([v_uv, v_uv1])).rgb);
983   #endif
984 
985   #if USE_ANISOTROPY
986     vec2 anisoUV = v_uv * anisoTile.xy + anisoTile.zw;
987     vec4 anisoMap = texture2D(anisoRamp, anisoUV);
988     float jitterFactor = anisoMap.r * anisoJitter.x + anisoMap.g * anisoJitter.y;
989     float aoFactor = mix(1.0, 0.0, anisoAOStrength * pbr.x);
990 
991     vec4 hairSpec = clamp((anisotropyIndex(hairSpecMOffset, jitterFactor, hairSpecMAmt) * hairSpecColor01 * hairSpecIntensity + anisotropyIndex(hairSpecAOffset, jitterFactor, hairSpecAAmt) * hairSpecColor02 * hairSpecIntensity) *
992                           aoFactor *
993                           pow((1.0 - dot(v_normal, worldViewDir.xyz)), 2.25),
994                           0.0, 1.51);
995 
996     s.albedo.rgb += hairBaseColor.rgb + hairSpec.rgb;
997   #endif
998 }
999 
1000 
1001 #if CC_FORWARD_ADD                                                 
1002                                
1003                                
1004                                
1005   #if CC_PIPELINE_TYPE == 0                             
1006     #define LIGHTS_PER_PASS 1                             
1007   #else                             
1008     #define LIGHTS_PER_PASS 10                             
1009   #endif                             
1010                                
1011   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1012   uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];
1013   uniform vec4 cc_lightColor[LIGHTS_PER_PASS];
1014   uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];
1015   uniform vec4 cc_lightDir[LIGHTS_PER_PASS];
1016                              
1017   #endif                             
1018                                
1019                                
1020                                
1021                                
1022   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {                             
1023     float factor = distSqr * invSqrAttRadius;                             
1024     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);                             
1025     return smoothFactor * smoothFactor;                             
1026   }                             
1027                                
1028   float GetDistAtt (float distSqr, float invSqrAttRadius) {                             
1029     float attenuation = 1.0 / max(distSqr, 0.01*0.01);                             
1030     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);                             
1031     return attenuation;                             
1032   }                             
1033                                
1034   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {                             
1035     float cd = dot(litDir, L);                             
1036     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);                             
1037     return (attenuation * attenuation);                             
1038   }                             
1039                                
1040                                
1041   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0                             
1042   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {                             
1043     vec3 position;                             
1044     
1045     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1046     position = unpackHighpData(s.position, s.position_fract_part);
1047     #else
1048     position = s.position;
1049     #endif
1050     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                             
1051     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                             
1052     vec3 diffuseContrib = diffuse / PI;                             
1053                                
1054     vec3 N = normalize(s.normal);                             
1055     vec3 V = normalize(cc_cameraPos.xyz - position);                             
1056     float NV = max(abs(dot(N, V)), 0.0);                             
1057     specular = BRDFApprox(specular, s.roughness, NV);                             
1058     vec3 finalColor = vec3(0.0);                             
1059                                
1060     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);                             
1061                                
1062     for (int i = 0; i < LIGHTS_PER_PASS; i++) {                             
1063       if (i >= numLights) break;                             
1064       vec3 SLU = cc_lightPos[i].xyz - position;                             
1065       vec3 SL = normalize(SLU);                             
1066       vec3 SH = normalize(SL + V);                             
1067       float SNL = max(dot(N, SL), 0.0);                             
1068       float SNH = max(dot(N, SH), 0.0);                             
1069                                
1070       float distSqr = dot(SLU, SLU);                             
1071       float litRadius = cc_lightSizeRangeAngle[i].x;                             
1072       float litRadiusSqr = litRadius * litRadius;                             
1073       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);                             
1074       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);                             
1075       attRadiusSqrInv *= attRadiusSqrInv;                             
1076       float att = GetDistAtt(distSqr, attRadiusSqrInv);                             
1077       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                             
1078                                
1079       if (cc_lightPos[i].w > 0.0) {                             
1080         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);                             
1081         float cosOuter = cc_lightSizeRangeAngle[i].z;                             
1082         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                             
1083         float litAngleOffset = -cosOuter * litAngleScale;                             
1084         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);                             
1085       }                             
1086                                
1087       vec3 lightColor = cc_lightColor[i].rgb;                             
1088                                
1089       float shadow = 1.0;                             
1090       #if CC_RECEIVE_SHADOW                             
1091         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {                             
1092           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                             
1093         }                             
1094       #endif                             
1095                                
1096       lightColor *= shadow;                             
1097       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);                             
1098     }                             
1099                                
1100     return vec4(finalColor, 0.0);                             
1101   }                             
1102   #endif                             
1103                                
1104   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                       
1105   readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };                              
1106   readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };                              
1107   readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };                              
1108                                 
1109   struct CCLight                              
1110   {                              
1111     vec4 cc_lightPos;                              
1112     vec4 cc_lightColor;                              
1113     vec4 cc_lightSizeRangeAngle;                              
1114     vec4 cc_lightDir;                              
1115   };                              
1116                                 
1117   struct Cluster                              
1118   {                              
1119     vec3 minBounds;                              
1120     vec3 maxBounds;                              
1121   };                              
1122                                 
1123   struct LightGrid                              
1124   {                              
1125     uint offset;                              
1126     uint ccLights;                              
1127   };                              
1128                                 
1129                                 
1130                                 
1131   CCLight getCCLight(uint i)                              
1132   {                              
1133     CCLight light;                              
1134     light.cc_lightPos = b_ccLights[4u * i + 0u];                              
1135     light.cc_lightColor = b_ccLights[4u * i + 1u];                              
1136     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];                              
1137     light.cc_lightDir = b_ccLights[4u * i + 3u];                              
1138     return light;                              
1139   }                              
1140                                 
1141   LightGrid getLightGrid(uint cluster)                              
1142   {                              
1143     uvec4 gridvec = b_clusterLightGrid[cluster];                              
1144     LightGrid grid;                              
1145     grid.offset = gridvec.x;                              
1146     grid.ccLights = gridvec.y;                              
1147     return grid;                              
1148   }                              
1149                                 
1150   uint getGridLightIndex(uint start, uint offset)                              
1151   {                              
1152     return b_clusterLightIndices[start + offset];                              
1153   }                              
1154                                 
1155   uint getClusterZIndex(vec4 worldPos)                              
1156   {                              
1157     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);                              
1158     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));                              
1159     float eyeDepth = -(cc_matView * worldPos).z;                              
1160     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));                              
1161     return zIndex;                              
1162   }                              
1163                                 
1164   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)                              
1165   {                              
1166     uint zIndex = getClusterZIndex(worldPos);                              
1167     float clusterSizeX = ceil(cc_viewPort.z / float(16));                              
1168     float clusterSizeY = ceil(cc_viewPort.w / float(8));                              
1169     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);                              
1170     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;                              
1171     return cluster;                              
1172   }                              
1173                                 
1174   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {                              
1175     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);                              
1176     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);                              
1177     vec3 diffuseContrib = diffuse / PI;                              
1178                                 
1179     vec3 position;                              
1180     
1181     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES
1182     position = unpackHighpData(s.position, s.position_fract_part);
1183     #else
1184     position = s.position;
1185     #endif
1186                                 
1187     vec3 N = normalize(s.normal);                              
1188     vec3 V = normalize(cc_cameraPos.xyz - position);                              
1189     float NV = max(abs(dot(N, V)), 0.001);                              
1190     specular = BRDFApprox(specular, s.roughness, NV);                              
1191     vec3 finalColor = vec3(0.0);                              
1192                                 
1193     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));                              
1194     LightGrid grid = getLightGrid(cluster);                              
1195     uint numLights = grid.ccLights;                              
1196                                 
1197     for (uint i = 0u; i < 100u; i++) {                              
1198       if (i >= numLights) break;                              
1199       uint lightIndex = getGridLightIndex(grid.offset, i);                              
1200       CCLight light = getCCLight(lightIndex);                              
1201       vec3 SLU = light.cc_lightPos.xyz - position;                              
1202       vec3 SL = normalize(SLU);                              
1203       vec3 SH = normalize(SL + V);                              
1204       float SNL = max(dot(N, SL), 0.001);                              
1205       float SNH = max(dot(N, SH), 0.0);                              
1206                                 
1207       float distSqr = dot(SLU, SLU);                              
1208       float litRadius = light.cc_lightSizeRangeAngle.x;                              
1209       float litRadiusSqr = litRadius * litRadius;                              
1210       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));                              
1211       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);                              
1212       attRadiusSqrInv *= attRadiusSqrInv;                              
1213       float att = GetDistAtt(distSqr, attRadiusSqrInv);                              
1214       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);                              
1215                                 
1216       if (light.cc_lightPos.w > 0.0) {                              
1217         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);                              
1218         float cosOuter = light.cc_lightSizeRangeAngle.z;                              
1219         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);                              
1220         float litAngleOffset = -cosOuter * litAngleScale;                              
1221         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);                              
1222       }                              
1223                                 
1224       vec3 lightColor = light.cc_lightColor.rgb;                              
1225                                 
1226       float shadow = 1.0;                              
1227       #if CC_RECEIVE_SHADOW                              
1228         if (light.cc_lightPos.w > 0.0) {                              
1229           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);                              
1230         }                              
1231       #endif                              
1232                                 
1233       lightColor *= shadow;                              
1234       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);                              
1235     }                              
1236                                 
1237     return vec4(finalColor, 0.0);                              
1238   }                              
1239                                 
1240   #endif                                                           
1241                                                                    
1242                           
1243                                                                    
1244   void main () {                                                   
1245     StandardSurface s; surf(s);                                    
1246     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1                     
1247     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);  
1248     #else                                                          
1249     vec4 color = CCStandardShadingAdditive(s, v_shadowPos); 
1250     #endif                                                         
1251     gl_FragData[0] = CCFragOutput(color);                              
1252   }                                                                
1253                                                                    
1254 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING) 
1255                                                                    
1256                           
1257                                                                    
1258   void main () {                                                   
1259     StandardSurface s; surf(s);                                    
1260     vec4 color = CCStandardShadingBase(s, v_shadowPos);     
1261     CC_APPLY_FOG(color, s.position.xyz);                           
1262     gl_FragData[0] = CCFragOutput(color);                              
1263   }                                                                
1264                                                                    
1265 #elif CC_PIPELINE_TYPE == 1                
1266                                     
1267   vec2 signNotZero(vec2 v) {                                  
1268     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);                                  
1269   }                                  
1270   vec2 float32x3_to_oct(in vec3 v) {                                  
1271     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));                                  
1272     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;                                  
1273   }                                  
1274                                     
1275                                     
1276                                     
1277                                     
1278                                                                    
1279                           
1280                           
1281                           
1282                                                                    
1283   void main () {                                                   
1284     StandardSurface s; surf(s);                                    
1285     gl_FragData[0] = s.albedo;                                         
1286     gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic); 
1287     gl_FragData[2] = vec4(s.emissive, s.occlusion);                    
1288   }                                                                
1289                                                                    
1290 #endif                                                             
1291   
2 #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE 1  
3 #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS 1024  
4 #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS 1024  
5 #define CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS 128  
6 #define CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS 128  
7 #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT 0  
8 #define CC_PLATFORM_ANDROID_AND_WEBGL 0  
9 #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0  
10 #define CC_ENABLE_CLUSTERED_LIGHT_CULLING 0  
11 #define USE_INSTANCING 1  
12 #define USE_LIGHTMAP 1  
13 #define CC_RECEIVE_SHADOW 1  
14 #define USE_BATCHING 1  
15 #define CC_USE_MORPH 1  
16 #define CC_USE_SKINNING 1  
17 #define CC_MORPH_TARGET_COUNT 2  
18 #define CC_MORPH_PRECOMPUTED 1  
19 #define CC_MORPH_TARGET_HAS_POSITION 1  
20 #define CC_MORPH_TARGET_HAS_NORMAL 1  
21 #define CC_MORPH_TARGET_HAS_TANGENT 1  
22 #define CC_USE_BAKED_ANIMATION 1  
23 #define CC_USE_FOG 0  
24 #define CC_USE_ACCURATE_FOG 1  
25 #define USE_VERTEX_COLOR 1  
26 #define HAS_SECOND_UV 1  
27 #define CC_FORWARD_ADD 1  
28 #define USE_NORMAL_MAP 1  
29 #define SAMPLE_FROM_RT 1  
30 #define CC_USE_IBL 0  
31 #define CC_USE_DIFFUSEMAP 0  
32 #define USE_REFLECTION_DENOISE 1  
33 #define CC_USE_HDR 1  
34 #define USE_ALBEDO_MAP 1  
35 #define USE_PBR_MAP 1  
36 #define USE_METALLIC_ROUGHNESS_MAP 1  
37 #define USE_OCCLUSION_MAP 1  
38 #define USE_EMISSIVE_MAP 1  
39 #define USE_ALPHA_TEST 1  
40 #define USE_ANISOTROPY 1  
41 #define CC_PIPELINE_TYPE 0  
42 #define CC_FORCE_FORWARD_SHADING 1  
43  
44 #ifdef GL_EXT_draw_buffers  
45 #extension GL_EXT_draw_buffers: enable  
46 #endif  
47  
48 #ifdef GL_OES_standard_derivatives  
49 #extension GL_OES_standard_derivatives: enable  
50 #endif  
51  
52 #ifdef GL_EXT_shader_texture_lod  
53 #extension GL_EXT_shader_texture_lod: enable  
54 #endif  
55  
56 precision highp float;  
57 uniform highp mat4 cc_matView;  
58   uniform highp vec4 cc_cameraPos;  
59   uniform mediump vec4 cc_mainLitDir;  
60   uniform mediump vec4 cc_mainLitColor;  
61   uniform mediump vec4 cc_ambientSky;  
62   uniform mediump vec4 cc_ambientGround;  
63   uniform mediump vec4 cc_fogColor;  
64   uniform mediump vec4 cc_fogBase;  
65   uniform mediump vec4 cc_fogAdd;  
66   uniform mediump vec4 cc_nearFar;  
67   uniform mediump vec4 cc_viewPort;  
68  
69  
70  
71      uniform vec4 albedo;  
72      uniform vec4 albedoScaleAndCutoff;  
73      uniform vec4 pbrParams;  
74      uniform vec4 miscParams;  
75      uniform vec4 emissive;  
76      uniform vec4 emissiveScaleParam;  
77      uniform vec4 anisoTile;  
78      uniform vec4 hairBaseColor;  
79      uniform vec4 hairSpecColor01;  
80      uniform vec4 hairSpecColor02;  
81      uniform vec2 anisoJitter;  
82      uniform float anisoAOStrength;  
83      uniform float hairSpecMOffset;  
84      uniform float hairSpecAOffset;  
85      uniform float hairSpecMAmt;  
86      uniform float hairSpecAAmt;  
87      uniform float hairSpecIntensity;  
88  
89 float LinearFog(vec4 pos) {  
90   vec4 wPos = pos;  
91   float cam_dis = distance(cc_cameraPos, wPos);  
92   float fogStart = cc_fogBase.x;  
93   float fogEnd = cc_fogBase.y;  
94   return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);  
95 }  
96  
97 float ExpFog(vec4 pos) {  
98   vec4 wPos = pos;  
99   float fogAtten = cc_fogAdd.z;  
100   float fogStart = cc_fogBase.x;  
101   float fogDensity = cc_fogBase.z;  
102   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;  
103   float f = exp(-cam_dis * fogDensity);  
104   return f;  
105 }  
106  
107 float ExpSquaredFog(vec4 pos) {  
108   vec4 wPos = pos;  
109   float fogAtten = cc_fogAdd.z;  
110   float fogStart = cc_fogBase.x;  
111   float fogDensity = cc_fogBase.z;  
112   float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;  
113   float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);  
114   return f;  
115 }  
116  
117 float LayeredFog(vec4 pos) {  
118   vec4 wPos = pos;  
119   float fogAtten = cc_fogAdd.z;  
120   float _FogTop = cc_fogAdd.x;  
121   float _FogRange = cc_fogAdd.y;  
122   vec3 camWorldProj = cc_cameraPos.xyz;  
123   camWorldProj.y = 0.;  
124   vec3 worldPosProj = wPos.xyz;  
125   worldPosProj.y = 0.;  
126   float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;  
127   float fDeltaY, fDensityIntegral;  
128   if (cc_cameraPos.y > _FogTop) {  
129     if (wPos.y < _FogTop) {  
130       fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;  
131       fDensityIntegral = fDeltaY * fDeltaY * 0.5;  
132     } else {  
133       fDeltaY = 0.;  
134       fDensityIntegral = 0.;  
135     }  
136   } else {  
137     if (wPos.y < _FogTop) {  
138       float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;  
139       float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;  
140       fDeltaY = abs(fDeltaA - fDeltaB);  
141       fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));  
142     } else {  
143       fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;  
144       fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);  
145     }  
146   }  
147   float fDensity;  
148   if (fDeltaY != 0.) {  
149     fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;  
150   } else {  
151     fDensity = 0.;  
152   }  
153   float f = exp(-fDensity);  
154   return f;  
155 }  
156  
157 void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)  
158 {  
159   #if CC_USE_FOG == 0  
160 	factor = LinearFog(pos);  
161   #elif CC_USE_FOG == 1  
162     factor = ExpFog(pos);  
163   #elif CC_USE_FOG == 2  
164     factor = ExpSquaredFog(pos);  
165   #elif CC_USE_FOG == 3  
166     factor = LayeredFog(pos);  
167   #else  
168     factor = 1.0;  
169   #endif  
170 }  
171  
172 void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {  
173   color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);  
174 }  
175  
176  
177 #if !CC_USE_ACCURATE_FOG  
178 varying float v_fog_factor;  
179 #endif  
180  
181 void CC_APPLY_FOG(inout vec4 color) {  
182 #if !CC_USE_ACCURATE_FOG  
183     CC_APPLY_FOG_BASE(color, v_fog_factor);  
184 #endif  
185 }  
186  
187 void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {  
188 #if CC_USE_ACCURATE_FOG  
189     float factor;  
190     CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);  
191 #else  
192     float factor = v_fog_factor;  
193 #endif  
194     CC_APPLY_FOG_BASE(color, factor);  
195 }  
196  
197 vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {  
198  
199     #ifdef GL_EXT_shader_texture_lod  
200       return texture2DLodEXT(tex, coord, lod);  
201     #else  
202       return texture2D(tex, coord, lod);  
203     #endif  
204  
205 }  
206  
207 vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {  
208  
209     #ifdef GL_EXT_shader_texture_lod  
210       return textureCubeLodEXT(tex, coord, lod);  
211     #else  
212       return textureCube(tex, coord, lod);  
213     #endif  
214  
215 }  
216  
217  
218  
219  
220  
221  
222  
223  
224  
225  
226  
227 #define QUATER_PI         0.78539816340  
228 #define HALF_PI           1.57079632679  
229 #define PI                3.14159265359  
230 #define PI2               6.28318530718  
231 #define PI4               12.5663706144  
232  
233 #define INV_QUATER_PI     1.27323954474  
234 #define INV_HALF_PI       0.63661977237  
235 #define INV_PI            0.31830988618  
236 #define INV_PI2           0.15915494309  
237 #define INV_PI4           0.07957747155  
238  
239 #define EPSILON           1e-6  
240 #define EPSILON_LOWP      1e-4  
241 #define LOG2              1.442695  
242 #define EXP_VALUE         2.71828183f  
243 #define FP_MAX            65504.0  
244 #define FP_SCALE          0.0009765625  
245 #define FP_SCALE_INV      1024.0  
246 #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)  
247  
248  
249  
250  
251  
252  
253  
254 vec3 SRGBToLinear (vec3 gamma) {  
255   return gamma * gamma;  
256 }  
257 uniform highp mat4 cc_matLightView;  
258   uniform highp vec4 cc_shadowInvProjDepthInfo;  
259   uniform highp vec4 cc_shadowProjDepthInfo;  
260   uniform highp vec4 cc_shadowProjInfo;  
261   uniform mediump vec4 cc_shadowNFLSInfo;  
262   uniform mediump vec4 cc_shadowWHPBInfo;  
263   uniform mediump vec4 cc_shadowLPNNInfo;  
264  
265  
266  
267  
268  
269  
270  
271  
272 highp float unpackHighpData (float mainPart, float modPart) {  
273   highp float data = mainPart;  
274   return data + modPart;  
275 }  
276  
277 highp float unpackHighpData (float mainPart, float modPart, const float modValue) {  
278   highp float data = mainPart * modValue;  
279   return data + modPart * modValue;  
280 }  
281  
282  
283 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {  
284   highp vec2 data = mainPart;  
285   return data + modPart;  
286 }  
287  
288 highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {  
289   highp vec2 data = mainPart * modValue;  
290   return data + modPart * modValue;  
291 }  
292  
293  
294 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {  
295   highp vec3 data = mainPart;  
296   return data + modPart;  
297 }  
298  
299 highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {  
300   highp vec3 data = mainPart * modValue;  
301   return data + modPart * modValue;  
302 }  
303  
304  
305 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {  
306   highp vec4 data = mainPart;  
307   return data + modPart;  
308 }  
309  
310 highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {  
311   highp vec4 data = mainPart * modValue;  
312   return data + modPart * modValue;  
313 }  
314 float CCGetLinearDepthFromViewSpace(vec3 viewPos) {  
315   float dist = length(viewPos);  
316   return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);  
317 }  
318  
319 float CCGetLinearDepth(vec3 worldPos) {  
320   vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);  
321   return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);  
322 }  
323  
324  
325  
326 #if CC_RECEIVE_SHADOW  
327   uniform highp sampler2D cc_shadowMap;  
328   uniform highp sampler2D cc_spotLightingMap;  
329  
330   vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)  
331   {  
332     vec4 newShadowPos = shadowPos;  
333     if(normalBias > EPSILON_LOWP)  
334     {  
335       vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);  
336       if(viewNormal.z < 0.1)  
337         newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);  
338     }  
339     return newShadowPos;  
340   }  
341  
342   vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)  
343   {  
344     vec3 viewSpacePos;  
345     viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;  
346     viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;  
347     viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;  
348     vec4 clipSpacePos;  
349     clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;  
350     clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);  
351     if (cc_shadowNFLSInfo.z > EPSILON) {  
352       clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);  
353       clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;  
354     }  
355  
356     return clipSpacePos;  
357   }  
358  
359   vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)  
360   {  
361     float coeffA = cc_shadowProjDepthInfo.x;  
362     float coeffB = cc_shadowProjDepthInfo.y;  
363     float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;  
364     viewSpacePos_z += viewspaceDepthBias;  
365     vec4 result = shadowPos;  
366     result.z = viewSpacePos_z * coeffA + coeffB;  
367     return result;  
368   }  
369  
370   float CCGetShadowFactorHard (vec4 shadowPos, float bias) {  
371     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
372     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
373     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
374         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
375         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
376     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
377  
378     float shadow = 0.0;  
379     float closestDepth = 0.0;  
380     if (cc_shadowLPNNInfo.y > EPSILON) {  
381       closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
382     } else {  
383       closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;  
384     }  
385     shadow = step(clipPos.z, closestDepth);  
386  
387     return shadow;  
388   }  
389  
390   float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {  
391     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
392     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
393     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
394         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
395         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
396     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
397  
398     float offsetDepth = clipPos.z;  
399     vec2 mapSize = cc_shadowWHPBInfo.xy;  
400     vec2 oneTap = 1.0 / mapSize;  
401     vec2 clipPos_offset = clipPos.xy + oneTap;  
402  
403     float block0, block1, block2, block3;  
404     if (cc_shadowLPNNInfo.y > EPSILON) {  
405       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
406       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
407       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
408       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
409     } else {  
410       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
411       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);  
412       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);  
413       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
414     }  
415  
416     float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;  
417     float resultX = mix(block0, block1, coefX);  
418     float resultY = mix(block2, block3, coefX);  
419     float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;  
420  
421     return mix(resultX, resultY, coefY);  
422   }  
423  
424   float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {  
425     vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);  
426     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
427     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
428         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
429         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
430     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
431  
432     float offsetDepth = clipPos.z;  
433     vec2 mapSize = cc_shadowWHPBInfo.xy;  
434     vec2 oneTap = 1.0 / mapSize;  
435     float clipPos_offset_L = clipPos.x - oneTap.x;  
436     float clipPos_offset_R = clipPos.x + oneTap.x;  
437     float clipPos_offset_U = clipPos.y - oneTap.y;  
438     float clipPos_offset_D = clipPos.y + oneTap.y;  
439  
440     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
441     if (cc_shadowLPNNInfo.y > EPSILON) {  
442       block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
443       block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
444       block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
445       block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
446       block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
447       block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
448       block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
449       block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
450       block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
451     } else {  
452       block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
453       block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);  
454       block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
455       block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);  
456       block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);  
457       block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);  
458       block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
459       block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);  
460       block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
461     }  
462  
463     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
464     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
465  
466     float shadow = 0.0;  
467     float resultX = mix(block0, block1, coefX);  
468     float resultY = mix(block3, block4, coefX);  
469     shadow += mix(resultX , resultY, coefY);  
470  
471     resultX = mix(block1, block2, coefX);  
472     resultY = mix(block4, block5, coefX);  
473     shadow += mix(resultX , resultY, coefY);  
474  
475     resultX = mix(block3, block4, coefX);  
476     resultY = mix(block6, block7, coefX);  
477     shadow += mix(resultX, resultY, coefY);  
478  
479     resultX = mix(block4, block5, coefX);  
480     resultY = mix(block7, block8, coefX);  
481     shadow += mix(resultX, resultY, coefY);  
482  
483     return shadow * 0.25;  
484   }  
485  
486   float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {  
487     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);  
488     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
489     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
490         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
491         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
492     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
493  
494     float shadow = 0.0;  
495     float closestDepth = 0.0;  
496     float depth = clipPos.z;  
497  
498     if (cc_shadowLPNNInfo.y > EPSILON) {  
499       closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));  
500     } else {  
501       closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;  
502     }  
503     shadow = step(depth, closestDepth);  
504  
505     return shadow;  
506   }  
507  
508   float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {  
509     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);  
510     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
511     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
512         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
513         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
514     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
515  
516     float depth = 0.0;  
517     if (cc_shadowNFLSInfo.z > EPSILON) {  
518       depth = CCGetLinearDepth(worldPos);  
519     } else {  
520       depth = clipPos.z;  
521     }  
522  
523     vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;  
524     vec2 clipPos_offset = clipPos.xy + oneTap;  
525  
526     float block0, block1, block2, block3;  
527     if (cc_shadowLPNNInfo.y > EPSILON) {  
528       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
529       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
530       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
531       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
532     } else {  
533       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);  
534       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);  
535       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);  
536       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);  
537     }  
538  
539     float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;  
540     float resultX = mix(block0, block1, coefX);  
541     float resultY = mix(block2, block3, coefX);  
542     float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;  
543  
544     return mix(resultX, resultY, coefY);  
545   }  
546  
547   float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {  
548     vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);  
549     vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;  
550     if (clipPos.x < 0.0 || clipPos.x > 1.0 ||  
551         clipPos.y < 0.0 || clipPos.y > 1.0 ||  
552         clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }  
553     clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;  
554  
555     float depth = 0.0;  
556     if (cc_shadowNFLSInfo.z > EPSILON) {  
557       depth = CCGetLinearDepth(worldPos);  
558     } else {  
559       depth = clipPos.z;  
560     }  
561  
562     vec2 mapSize = cc_shadowWHPBInfo.xy;  
563     vec2 oneTap = 1.0 / mapSize;  
564     float clipPos_offset_L = clipPos.x - oneTap.x;  
565     float clipPos_offset_R = clipPos.x + oneTap.x;  
566     float clipPos_offset_U = clipPos.y - oneTap.y;  
567     float clipPos_offset_D = clipPos.y + oneTap.y;  
568  
569     float block0, block1, block2, block3, block4, block5, block6, block7, block8;  
570     if (cc_shadowLPNNInfo.y > EPSILON) {  
571       block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
572       block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
573       block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
574       block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
575       block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
576       block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
577       block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
578       block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
579       block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));  
580     } else {  
581       block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);  
582       block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);  
583       block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);  
584       block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);  
585       block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);  
586       block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);  
587       block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);  
588       block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);  
589       block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);  
590     }  
591  
592     float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;  
593     float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;  
594  
595     float shadow = 0.0;  
596     float resultX = mix(block0, block1, coefX);  
597     float resultY = mix(block3, block4, coefX);  
598     shadow += mix(resultX , resultY, coefY);  
599  
600     resultX = mix(block1, block2, coefX);  
601     resultY = mix(block4, block5, coefX);  
602     shadow += mix(resultX , resultY, coefY);  
603  
604     resultX = mix(block3, block4, coefX);  
605     resultY = mix(block6, block7, coefX);  
606     shadow += mix(resultX, resultY, coefY);  
607  
608     resultX = mix(block4, block5, coefX);  
609     resultY = mix(block7, block8, coefX);  
610     shadow += mix(resultX, resultY, coefY);  
611  
612     return shadow * 0.25;  
613   }  
614  
615 float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)  
616 {  
617   float pcf = cc_shadowWHPBInfo.z;  
618   if (pcf > 1.9) {  
619     return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);  
620   }else if (pcf > 0.9) {  
621     return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);  
622   }else {  
623     return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);  
624   }  
625 }  
626  
627 float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)  
628 {  
629   float realtimeShadow = 1.0;  
630   vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);  
631  
632   float pcf = cc_shadowWHPBInfo.z;  
633   if (pcf > 1.9) {  
634     realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);  
635   }else if (pcf > 0.9) {  
636     realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);  
637   }else {  
638     realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);  
639   }  
640   return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);  
641 }  
642 #endif  
643  
644  
645  
646 #if CC_USE_IBL  
647   uniform samplerCube cc_environment;  
648  
649  
650  
651  
652   vec3 unpackRGBE (vec4 rgbe) {  
653     return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);  
654   }  
655  
656  
657   #if CC_USE_DIFFUSEMAP  
658     uniform samplerCube cc_diffuseMap;  
659   #endif  
660 #endif  
661  
662 float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {  
663   vec3 NxH = cross(N, H);  
664   float OneMinusNoHSqr = dot(NxH, NxH);  
665   float a = roughness * roughness;  
666   float n = NoH * a;  
667   float p = a / (OneMinusNoHSqr + n * n);  
668   return p * p;  
669 }  
670  
671 float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {  
672   return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);  
673 }  
674  
675 vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {  
676   const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);  
677   const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);  
678   vec4 r = roughness * c0 + c1;  
679   float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;  
680   vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;  
681   AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);  
682   return specular * AB.x + AB.y;  
683 }  
684  
685 #if USE_REFLECTION_DENOISE  
686   vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {  
687     #if CC_USE_IBL  
688     	float mip = roughness * mipCount;  
689     	float delta = (dot(dFdx(R), dFdy(R))) * 1000.0;  
690     	float mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));  
691  
692     	vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);  
693      	vec4 filtered = textureCube(cc_environment, R);  
694  
695       #if CC_USE_IBL == 2  
696       	biased.rgb = unpackRGBE(biased);  
697       	filtered.rgb = unpackRGBE(filtered);  
698       #else  
699       	biased.rgb = SRGBToLinear(biased.rgb);  
700       	filtered.rgb = SRGBToLinear(filtered.rgb);  
701       #endif  
702  
703       return mix(biased.rgb, filtered.rgb, denoiseIntensity);  
704     #else  
705       return vec3(0.0, 0.0, 0.0);  
706     #endif  
707   }  
708 #endif  
709  
710  
711 struct StandardSurface {  
712   vec4 albedo;  
713  
714   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
715   vec3 position, position_fract_part;  
716   #else  
717   vec3 position;  
718   #endif  
719   vec3 normal;  
720   vec3 emissive;  
721   vec3 lightmap;  
722   float lightmap_test;  
723   float roughness;  
724   float metallic;  
725   float occlusion;  
726   float specularIntensity;  
727  
728   #if CC_RECEIVE_SHADOW  
729     vec2 shadowBias;  
730   #endif  
731 };  
732  
733 vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {  
734   vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
735  
736   vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);  
737  
738   vec3 position;  
739  
740   #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
741   position = unpackHighpData(s.position, s.position_fract_part);  
742   #else  
743   position = s.position;  
744   #endif  
745  
746   vec3 N = normalize(s.normal);  
747   vec3 V = normalize(cc_cameraPos.xyz - position);  
748  
749   float NV = max(abs(dot(N, V)), 0.0);  
750   specular = BRDFApprox(specular, s.roughness, NV);  
751  
752   vec3 L = normalize(-cc_mainLitDir.xyz);  
753   vec3 H = normalize(L + V);  
754   float NH = max(dot(N, H), 0.0);  
755   float NL = max(dot(N, L), 0.0);  
756   vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;  
757   vec3 diffuseContrib = diffuse / PI;  
758   vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);  
759   vec3 dirlightContrib = (diffuseContrib + specularContrib);  
760  
761   float shadow = 1.0;  
762   #if CC_RECEIVE_SHADOW  
763     if (NL > 0.0 && cc_mainLitDir.w > 0.0) {  
764       shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);  
765     }  
766   #endif  
767  
768   dirlightContrib *= shadow;  
769   finalColor *= dirlightContrib;  
770  
771   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
772     if (s.lightmap_test > EPSILON_LOWP) {  
773       finalColor = diffuse * s.lightmap.rgb * shadow;  
774     }  
775   #endif  
776  
777   float fAmb = 0.5 - N.y * 0.5;  
778   vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);  
779  
780  
781   #if CC_USE_IBL  
782     #if CC_USE_DIFFUSEMAP  
783       vec4 diffuseMap = textureCube(cc_diffuseMap, N);  
784       #if CC_USE_DIFFUSEMAP == 2  
785         ambDiff = unpackRGBE(diffuseMap);  
786       #else  
787         ambDiff = SRGBToLinear(diffuseMap.rgb);  
788       #endif  
789     #endif  
790  
791     vec3 R = normalize(reflect(-V, N));  
792  
793     #if USE_REFLECTION_DENOISE  
794       vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);  
795     #else  
796       vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);  
797  
798       #if CC_USE_IBL == 2  
799         vec3 env = unpackRGBE(envmap);  
800       #else  
801         vec3 env = SRGBToLinear(envmap.rgb);  
802       #endif  
803     #endif  
804  
805     finalColor += env * cc_ambientSky.w * specular * s.occlusion;  
806   #endif  
807  
808   finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;  
809  
810  
811   finalColor += s.emissive;  
812  
813   return vec4(finalColor, s.albedo.a);  
814 }  
815  
816  
817  
818 vec3 ACESToneMap (vec3 color) {  
819   color = min(color, vec3(8.0));  
820   const float A = 2.51;  
821   const float B = 0.03;  
822   const float C = 2.43;  
823   const float D = 0.59;  
824   const float E = 0.14;  
825   return (color * (A * color + B)) / (color * (C * color + D) + E);  
826 }  
827  
828  
829  
830 vec4 CCFragOutput (vec4 color) {  
831   #if CC_USE_HDR  
832     color.rgb = ACESToneMap(color.rgb);  
833   #endif  
834   color.rgb = sqrt(color.rgb);  
835   return color;  
836 }  
837  
838  
839  
840  
841 varying highp vec4 v_shadowPos;  
842  
843  
844  
845 #if CC_RECEIVE_SHADOW  
846  
847  
848  
849 #endif  
850  
851  
852  
853  
854 #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
855   varying vec3 v_luv;  
856   uniform sampler2D cc_lightingMap;  
857  
858 #endif  
859  
860 void alphaTestFunc(float alpha)  
861 {  
862   if (alpha < albedoScaleAndCutoff.w) discard;  
863 }  
864  
865  
866 varying vec3 v_position;  
867 varying vec2 v_uv;  
868 varying vec2 v_uv1;  
869 varying vec3 v_normal;  
870 varying vec3 v_tangent;  
871 varying vec3 v_bitangent;  
872  
873 varying vec4 worldViewDir;  
874 varying vec4 worldHalfDir;  
875  
876 #if USE_VERTEX_COLOR  
877   varying vec4 v_color;  
878 #endif  
879  
880 #if USE_ALBEDO_MAP  
881   uniform sampler2D albedoMap;  
882   #endif  
883 #if USE_NORMAL_MAP  
884   uniform sampler2D normalMap;  
885   #endif  
886 #if USE_PBR_MAP  
887   uniform sampler2D pbrMap;  
888 #endif  
889 #if USE_METALLIC_ROUGHNESS_MAP  
890   uniform sampler2D metallicRoughnessMap;  
891 #endif  
892 #if USE_OCCLUSION_MAP  
893   uniform sampler2D occlusionMap;  
894 #endif  
895 #if USE_EMISSIVE_MAP  
896   uniform sampler2D emissiveMap;  
897   #endif  
898  
899 #define OCCLUSION_CHANNEL r  
900 #define ROUGHNESS_CHANNEL g  
901 #define METALLIC_CHANNEL  b  
902 #define SPECULARINTENSITY_CHANNEL w  
903  
904  
905 #if USE_ALPHA_TEST  
906   #endif  
907  
908 #if USE_ANISOTROPY  
909   uniform sampler2D anisoRamp;  
910 #endif  
911  
912 float anisotropyIndex( float offset, float factor, float amt ) {  
913   vec3 jitterN = v_bitangent + (v_normal * offset + factor);  
914   float NHdot = dot(normalize(jitterN), normalize(worldHalfDir.xyz));  
915   float sinNH = max(0.01, sqrt(1.0 - pow(NHdot, 2.0)));  
916   float atten = smoothstep(-1.0, 0.0, NHdot);  
917   return pow(sinNH, amt) * atten;  
918 }  
919  
920 void surf (out StandardSurface s) {  
921   vec4 baseColor = albedo;  
922  
923   #if USE_VERTEX_COLOR  
924     baseColor.rgb *= SRGBToLinear(v_color.rgb);  
925     baseColor.a *= v_color.a;  
926   #endif  
927  
928   #if USE_ALBEDO_MAP  
929     vec4 texColor = texture2D(albedoMap, options([v_uv, v_uv1]));  
930     texColor.rgb = SRGBToLinear(texColor.rgb);  
931     baseColor *= texColor;  
932   #endif  
933  
934   s.albedo = baseColor;  
935   s.albedo.rgb *= albedoScaleAndCutoff.xyz;  
936  
937   #if USE_ALPHA_TEST  
938     alphaTestFunc(s.albedo.options([a, r]));  
939   #endif  
940  
941   #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD  
942     vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);  
943     s.lightmap = UnpackLightingmap(lightColor);  
944     s.lightmap_test = v_luv.z;  
945   #endif  
946  
947   s.normal = v_normal;  
948   #if USE_NORMAL_MAP  
949     vec3 nmmp = texture2D(normalMap, options([v_uv, v_uv1])).xyz - vec3(0.5);  
950     s.normal =  
951       (nmmp.x * miscParams.x) * normalize(v_tangent) +  
952       (nmmp.y * miscParams.x) * normalize(v_bitangent) +  
953       nmmp.z * normalize(s.normal);  
954   #endif  
955  
956   s.position = v_position;  
957  
958   vec4 pbr = pbrParams;  
959   #if USE_PBR_MAP  
960     vec4 res = texture2D(pbrMap, options([v_uv, v_uv1]));  
961     pbr.x *= res.OCCLUSION_CHANNEL;  
962     pbr.y *= res.ROUGHNESS_CHANNEL;  
963     pbr.z *= res.METALLIC_CHANNEL;  
964     pbr.w *= res.SPECULARINTENSITY_CHANNEL;  
965   #endif  
966  
967   #if USE_METALLIC_ROUGHNESS_MAP  
968     vec4 metallicRoughness = texture2D(metallicRoughnessMap, options([v_uv, v_uv1]));  
969     pbr.z *= metallicRoughness.METALLIC_CHANNEL;  
970     pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;  
971   #endif  
972  
973   #if USE_OCCLUSION_MAP  
974     pbr.x *= texture2D(occlusionMap, options([v_uv, v_uv1])).OCCLUSION_CHANNEL;  
975   #endif  
976   s.occlusion = clamp(pbr.x, 0.0, 0.96);  
977   s.roughness = clamp(pbr.y, 0.04, 1.0);  
978   s.metallic = pbr.z;  
979  
980   s.emissive = emissive.rgb * emissiveScaleParam.xyz;  
981   #if USE_EMISSIVE_MAP  
982     s.emissive *= SRGBToLinear(texture2D(emissiveMap, options([v_uv, v_uv1])).rgb);  
983   #endif  
984  
985   #if USE_ANISOTROPY  
986     vec2 anisoUV = v_uv * anisoTile.xy + anisoTile.zw;  
987     vec4 anisoMap = texture2D(anisoRamp, anisoUV);  
988     float jitterFactor = anisoMap.r * anisoJitter.x + anisoMap.g * anisoJitter.y;  
989     float aoFactor = mix(1.0, 0.0, anisoAOStrength * pbr.x);  
990  
991     vec4 hairSpec = clamp((anisotropyIndex(hairSpecMOffset, jitterFactor, hairSpecMAmt) * hairSpecColor01 * hairSpecIntensity + anisotropyIndex(hairSpecAOffset, jitterFactor, hairSpecAAmt) * hairSpecColor02 * hairSpecIntensity) *  
992                           aoFactor *  
993                           pow((1.0 - dot(v_normal, worldViewDir.xyz)), 2.25),  
994                           0.0, 1.51);  
995  
996     s.albedo.rgb += hairBaseColor.rgb + hairSpec.rgb;  
997   #endif  
998 }  
999  
1000  
1001 #if CC_FORWARD_ADD  
1002  
1003  
1004  
1005   #if CC_PIPELINE_TYPE == 0  
1006     #define LIGHTS_PER_PASS 1  
1007   #else  
1008     #define LIGHTS_PER_PASS 10  
1009   #endif  
1010  
1011   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0  
1012   uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];  
1013   uniform vec4 cc_lightColor[LIGHTS_PER_PASS];  
1014   uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];  
1015   uniform vec4 cc_lightDir[LIGHTS_PER_PASS];  
1016  
1017   #endif  
1018  
1019  
1020  
1021  
1022   float SmoothDistAtt (float distSqr, float invSqrAttRadius) {  
1023     float factor = distSqr * invSqrAttRadius;  
1024     float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);  
1025     return smoothFactor * smoothFactor;  
1026   }  
1027  
1028   float GetDistAtt (float distSqr, float invSqrAttRadius) {  
1029     float attenuation = 1.0 / max(distSqr, 0.01*0.01);  
1030     attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);  
1031     return attenuation;  
1032   }  
1033  
1034   float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {  
1035     float cd = dot(litDir, L);  
1036     float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);  
1037     return (attenuation * attenuation);  
1038   }  
1039  
1040  
1041   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0  
1042   vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {  
1043     vec3 position;  
1044  
1045     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
1046     position = unpackHighpData(s.position, s.position_fract_part);  
1047     #else  
1048     position = s.position;  
1049     #endif  
1050     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
1051     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);  
1052     vec3 diffuseContrib = diffuse / PI;  
1053  
1054     vec3 N = normalize(s.normal);  
1055     vec3 V = normalize(cc_cameraPos.xyz - position);  
1056     float NV = max(abs(dot(N, V)), 0.0);  
1057     specular = BRDFApprox(specular, s.roughness, NV);  
1058     vec3 finalColor = vec3(0.0);  
1059  
1060     int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);  
1061  
1062     for (int i = 0; i < LIGHTS_PER_PASS; i++) {  
1063       if (i >= numLights) break;  
1064       vec3 SLU = cc_lightPos[i].xyz - position;  
1065       vec3 SL = normalize(SLU);  
1066       vec3 SH = normalize(SL + V);  
1067       float SNL = max(dot(N, SL), 0.0);  
1068       float SNH = max(dot(N, SH), 0.0);  
1069  
1070       float distSqr = dot(SLU, SLU);  
1071       float litRadius = cc_lightSizeRangeAngle[i].x;  
1072       float litRadiusSqr = litRadius * litRadius;  
1073       float illum = litRadiusSqr / max(litRadiusSqr, distSqr);  
1074       float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);  
1075       attRadiusSqrInv *= attRadiusSqrInv;  
1076       float att = GetDistAtt(distSqr, attRadiusSqrInv);  
1077       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);  
1078  
1079       if (cc_lightPos[i].w > 0.0) {  
1080         float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);  
1081         float cosOuter = cc_lightSizeRangeAngle[i].z;  
1082         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);  
1083         float litAngleOffset = -cosOuter * litAngleScale;  
1084         att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);  
1085       }  
1086  
1087       vec3 lightColor = cc_lightColor[i].rgb;  
1088  
1089       float shadow = 1.0;  
1090       #if CC_RECEIVE_SHADOW  
1091         if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {  
1092           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);  
1093         }  
1094       #endif  
1095  
1096       lightColor *= shadow;  
1097       finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);  
1098     }  
1099  
1100     return vec4(finalColor, 0.0);  
1101   }  
1102   #endif  
1103  
1104   #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1  
1105   readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };  
1106   readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };  
1107   readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };  
1108  
1109   struct CCLight  
1110   {  
1111     vec4 cc_lightPos;  
1112     vec4 cc_lightColor;  
1113     vec4 cc_lightSizeRangeAngle;  
1114     vec4 cc_lightDir;  
1115   };  
1116  
1117   struct Cluster  
1118   {  
1119     vec3 minBounds;  
1120     vec3 maxBounds;  
1121   };  
1122  
1123   struct LightGrid  
1124   {  
1125     uint offset;  
1126     uint ccLights;  
1127   };  
1128  
1129  
1130  
1131   CCLight getCCLight(uint i)  
1132   {  
1133     CCLight light;  
1134     light.cc_lightPos = b_ccLights[4u * i + 0u];  
1135     light.cc_lightColor = b_ccLights[4u * i + 1u];  
1136     light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];  
1137     light.cc_lightDir = b_ccLights[4u * i + 3u];  
1138     return light;  
1139   }  
1140  
1141   LightGrid getLightGrid(uint cluster)  
1142   {  
1143     uvec4 gridvec = b_clusterLightGrid[cluster];  
1144     LightGrid grid;  
1145     grid.offset = gridvec.x;  
1146     grid.ccLights = gridvec.y;  
1147     return grid;  
1148   }  
1149  
1150   uint getGridLightIndex(uint start, uint offset)  
1151   {  
1152     return b_clusterLightIndices[start + offset];  
1153   }  
1154  
1155   uint getClusterZIndex(vec4 worldPos)  
1156   {  
1157     float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);  
1158     float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));  
1159     float eyeDepth = -(cc_matView * worldPos).z;  
1160     uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));  
1161     return zIndex;  
1162   }  
1163  
1164   uint getClusterIndex(vec4 fragCoord, vec4 worldPos)  
1165   {  
1166     uint zIndex = getClusterZIndex(worldPos);  
1167     float clusterSizeX = ceil(cc_viewPort.z / float(16));  
1168     float clusterSizeY = ceil(cc_viewPort.w / float(8));  
1169     uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);  
1170     uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;  
1171     return cluster;  
1172   }  
1173  
1174   vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {  
1175     vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);  
1176     vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);  
1177     vec3 diffuseContrib = diffuse / PI;  
1178  
1179     vec3 position;  
1180  
1181     #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES  
1182     position = unpackHighpData(s.position, s.position_fract_part);  
1183     #else  
1184     position = s.position;  
1185     #endif  
1186  
1187     vec3 N = normalize(s.normal);  
1188     vec3 V = normalize(cc_cameraPos.xyz - position);  
1189     float NV = max(abs(dot(N, V)), 0.001);  
1190     specular = BRDFApprox(specular, s.roughness, NV);  
1191     vec3 finalColor = vec3(0.0);  
1192  
1193     uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));  
1194     LightGrid grid = getLightGrid(cluster);  
1195     uint numLights = grid.ccLights;  
1196  
1197     for (uint i = 0u; i < 100u; i++) {  
1198       if (i >= numLights) break;  
1199       uint lightIndex = getGridLightIndex(grid.offset, i);  
1200       CCLight light = getCCLight(lightIndex);  
1201       vec3 SLU = light.cc_lightPos.xyz - position;  
1202       vec3 SL = normalize(SLU);  
1203       vec3 SH = normalize(SL + V);  
1204       float SNL = max(dot(N, SL), 0.001);  
1205       float SNH = max(dot(N, SH), 0.0);  
1206  
1207       float distSqr = dot(SLU, SLU);  
1208       float litRadius = light.cc_lightSizeRangeAngle.x;  
1209       float litRadiusSqr = litRadius * litRadius;  
1210       float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));  
1211       float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);  
1212       attRadiusSqrInv *= attRadiusSqrInv;  
1213       float att = GetDistAtt(distSqr, attRadiusSqrInv);  
1214       vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);  
1215  
1216       if (light.cc_lightPos.w > 0.0) {  
1217         float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);  
1218         float cosOuter = light.cc_lightSizeRangeAngle.z;  
1219         float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);  
1220         float litAngleOffset = -cosOuter * litAngleScale;  
1221         att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);  
1222       }  
1223  
1224       vec3 lightColor = light.cc_lightColor.rgb;  
1225  
1226       float shadow = 1.0;  
1227       #if CC_RECEIVE_SHADOW  
1228         if (light.cc_lightPos.w > 0.0) {  
1229           shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);  
1230         }  
1231       #endif  
1232  
1233       lightColor *= shadow;  
1234       finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);  
1235     }  
1236  
1237     return vec4(finalColor, 0.0);  
1238   }  
1239  
1240   #endif  
1241  
1242  
1243  
1244   void main () {  
1245     StandardSurface s; surf(s);  
1246     #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1  
1247     vec4 color = CCClusterShadingAdditive(s, v_shadowPos);  
1248     #else  
1249     vec4 color = CCStandardShadingAdditive(s, v_shadowPos);  
1250     #endif  
1251     gl_FragData[0] = CCFragOutput(color);  
1252   }  
1253  
1254 #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)  
1255  
1256  
1257  
1258   void main () {  
1259     StandardSurface s; surf(s);  
1260     vec4 color = CCStandardShadingBase(s, v_shadowPos);  
1261     CC_APPLY_FOG(color, s.position.xyz);  
1262     gl_FragData[0] = CCFragOutput(color);  
1263   }  
1264  
1265 #elif CC_PIPELINE_TYPE == 1  
1266  
1267   vec2 signNotZero(vec2 v) {  
1268     return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);  
1269   }  
1270   vec2 float32x3_to_oct(in vec3 v) {  
1271     vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));  
1272     return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;  
1273   }  
1274  
1275  
1276  
1277  
1278  
1279  
1280  
1281  
1282  
1283   void main () {  
1284     StandardSurface s; surf(s);  
1285     gl_FragData[0] = s.albedo;  
1286     gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);  
1287     gl_FragData[2] = vec4(s.emissive, s.occlusion);  
1288   }  
1289  
1290 #endif  
1291  
at Object.encode (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-worker\node_modules\v-stacks\index.js:14:17)  
at Logger._logHandler (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-worker\static\script.ccc:1:531)  
at Logger.record (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-logger\lib\renderer.ccc:1:458)  
at console.error (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@base\electron-logger\lib\renderer.ccc:1:1414)  
at EffectImporter.import (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\effect.ccc:1:1894)  
at ImportTask.importAsset (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:2325)  
at runNextTicks (internal/process/task_queues.js:58:5)  
at processImmediate (internal/timers.js:434:9)  
at async ImportTask.exec (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:596)  
at async ParallelQueue._generate (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\asset-db.ccc:1:2655)
2022-05-05T03:01:00.716Z - error: [Asset DB] J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json: ENOENT: no such file or directory, open 'J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json'Error: J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json: ENOENT: no such file or directory, open 'J:\Cocos\cocos-task\performanceTest\library\81\81b5ca25-e46d-4fea-9359-eca2bc2109ac.json'
    at Object.openSync (fs.js:476:3)
    at Object.func [as openSync] (electron/js2c/asar_bundle.js:5:1846)
    at Object.readFileSync (fs.js:377:35)
    at Object.e.readFileSync (electron/js2c/asar_bundle.js:5:8872)
    at Object.readFileSync (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\jsonfile\index.js:61:22)
    at Object.upgradeProperties (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\utils\material-upgrader.ccc:1:1795)
    at async MaterialImporter.import (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\modules\engine-extensions\extensions\engine-extends\dist\importer\importers\material.ccc:1:701)
    at async ImportTask.importAsset (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:2311)
    at async ImportTask.exec (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\task.ccc:1:596)
    at async ParallelQueue._generate (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\asset-db\libs\asset-db.ccc:1:2655)
2022-05-05T03:01:00.747Z - verbose: [Scene] Require engine code (0ms)
2022-05-05T03:01:00.747Z - verbose: [Scene] Startup engine (1ms)
2022-05-05T03:01:00.764Z - log: [Scene] Cocos Creator v3.5.0
2022-05-05T03:01:01.623Z - verbose: [Scene] Open engine (875ms)
2022-05-05T03:01:01.623Z - verbose: [Scene] Configure engine (0ms)
2022-05-05T03:01:01.247Z - info: [Scene] Forward render pipeline initialized.
2022-05-05T03:01:01.681Z - error: [Scene] download failed: import://81/81b5ca25-e46d-4fea-9359-eca2bc2109ac.json?_t=1651719661649, status: 0(error)Error: download failed: import://81/81b5ca25-e46d-4fea-9359-eca2bc2109ac.json?_t=1651719661649, status: 0(error)
    at XMLHttpRequest.<anonymous> (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:90000:18)
2022-05-05T03:01:03.958Z - error: [Window] The "path" argument must be of type string or an instance of Buffer or URL. Received undefinedTypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
    at Object.openSync (fs.js:468:10)
    at Object.func [as openSync] (electron/js2c/asar_bundle.js:5:1846)
    at readFileSync (fs.js:377:35)
    at e.readFileSync (electron/js2c/asar_bundle.js:5:8872)
    at Object.refresh (J:\Cocos\engine\editor\inspector\assets\effect.js:308:39)
    at Object.<anonymous> (J:\Cocos\engine\editor\inspector\assets\effect.js:279:26)
    at HTMLElement.update (J:\Cocos\CocosCreator-v3.5.0-win-041909\resources\app.asar\node_modules\@editor\creator\dist\ui-kit\renderer\components\panel\index.ccc:1:1685)
    at J:\Cocos\engine\editor\inspector\contributions\asset.js:325:28
    at Array.forEach (<anonymous>)
    at Object.update (J:\Cocos\engine\editor\inspector\contributions\asset.js:323:41)
2022-05-05T03:01:08.231Z - error: [Scene] The asset 70a2d437-9803-4f86-af39-a837a830e65a is invalid for some reason and will be reverted to default asset, please check it out!Error: [Scene] The asset 70a2d437-9803-4f86-af39-a837a830e65a is invalid for some reason and will be reverted to default asset, please check it out!
    at error (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138654:10)
    at Task.onComplete (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:91620:28)
    at Task.dispatch (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:93650:16)
    at J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:92403:16
    at J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:91423:5
    at cb (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:95005:9)
    at Task.onComplete (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:91407:9)
2022-05-05T03:01:08.231Z - warn: [Scene] Material already initialized, request aborted.Error: [Scene] Material already initialized, request aborted.
    at warn (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138636:10)
    at warnID (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138855:3)
    at Proxy.initialize (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:96137:25)
    at Proxy.initDefault (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:96533:10)
    at Task.onComplete (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:91621:17)
    at Task.dispatch (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:93650:16)
    at J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:92403:16
2022-05-05T03:01:08.404Z - error: [Scene] The asset 16517196684030.49900966835518124 is invalid for some reason and will be reverted to default asset, please check it out!Error: [Scene] The asset 16517196684030.49900966835518124 is invalid for some reason and will be reverted to default asset, please check it out!
    at error (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138654:10)
    at Task.onComplete (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:91620:28)
    at Task.dispatch (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:93650:16)
    at J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:92403:16
    at J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:91423:5
    at cb (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:95005:9)
    at Task.onComplete (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:91407:9)
2022-05-05T03:01:22.144Z - warn: [Scene] Node "cjie2" has no path "root/footsteps".Error: [Scene] Node "cjie2" has no path "root/footsteps".
    at warn (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138636:10)
    at warnID (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138855:3)
    at HierarchyPath.get (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:86256:25)
    at TrackPath.[NormalizedFollow] (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215057:23)
    at TrackBinding.createRuntimeBinding (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215108:53)
    at binder (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:80886:35)
    at createExoticTrackEvaluationRecord (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:209689:26)
2022-05-05T03:01:22.144Z - warn: [Scene] Node "cjie2" has no path "root/footsteps".Error: [Scene] Node "cjie2" has no path "root/footsteps".
    at warn (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138636:10)
    at warnID (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138855:3)
    at HierarchyPath.get (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:86256:25)
    at TrackPath.[NormalizedFollow] (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215057:23)
    at TrackBinding.createRuntimeBinding (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215108:53)
    at binder (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:80886:35)
    at createExoticTrackEvaluationRecord (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:209689:26)
2022-05-05T03:01:22.145Z - warn: [Scene] Node "cjie2" has no path "root/footsteps".Error: [Scene] Node "cjie2" has no path "root/footsteps".
    at warn (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138636:10)
    at warnID (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138855:3)
    at HierarchyPath.get (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:86256:25)
    at TrackPath.[NormalizedFollow] (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215057:23)
    at TrackBinding.createRuntimeBinding (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215108:53)
    at binder (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:80886:35)
    at createExoticTrackEvaluationRecord (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:209689:26)
2022-05-05T03:01:31.941Z - error: [Scene] download failed: import://70/70a2d437-9803-4f86-af39-a837a830e65a.json?_t=1651719691938, status: 0(error)Error: download failed: import://70/70a2d437-9803-4f86-af39-a837a830e65a.json?_t=1651719691938, status: 0(error)
    at XMLHttpRequest.<anonymous> (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:90000:18)
2022-05-05T03:01:32.014Z - warn: [Scene] Node "cjie2" has no path "root/footsteps".Error: [Scene] Node "cjie2" has no path "root/footsteps".
    at warn (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138636:10)
    at warnID (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138855:3)
    at HierarchyPath.get (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:86256:25)
    at TrackPath.[NormalizedFollow] (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215057:23)
    at TrackBinding.createRuntimeBinding (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215108:53)
    at binder (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:80886:35)
    at createExoticTrackEvaluationRecord (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:209689:26)
2022-05-05T03:01:32.014Z - warn: [Scene] Node "cjie2" has no path "root/footsteps".Error: [Scene] Node "cjie2" has no path "root/footsteps".
    at warn (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138636:10)
    at warnID (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138855:3)
    at HierarchyPath.get (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:86256:25)
    at TrackPath.[NormalizedFollow] (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215057:23)
    at TrackBinding.createRuntimeBinding (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215108:53)
    at binder (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:80886:35)
    at createExoticTrackEvaluationRecord (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:209689:26)
2022-05-05T03:01:32.014Z - warn: [Scene] Node "cjie2" has no path "root/footsteps".Error: [Scene] Node "cjie2" has no path "root/footsteps".
    at warn (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138636:10)
    at warnID (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:138855:3)
    at HierarchyPath.get (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:86256:25)
    at TrackPath.[NormalizedFollow] (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215057:23)
    at TrackBinding.createRuntimeBinding (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:215108:53)
    at binder (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:80886:35)
    at createExoticTrackEvaluationRecord (J:\Cocos\engine\bin\.cache\dev\editor\bundled\index.js:209689:26)
2022-05-05T03:01:32.141Z - error: [Window] Cannot read property 'effect' of nullTypeError: Cannot read property 'effect' of null
    at Object.updateInterface (J:\Cocos\engine\editor\inspector\assets\material.js:149:45)
    at Object.<anonymous> (J:\Cocos\engine\editor\inspector\assets\material.js:422:16)
2022-05-05T03:06:27.291Z - warn: Metrics: no valid info
